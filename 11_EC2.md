[MC2: Rigorous and Effeicient Directed Greybox Fuzzing](https://arxiv.org/pdf/2208.14530.pdf)
# Abstract
- 기존 DGF는 performance나 optimality에 대한 이론적 분석을 제공하지 않음
- DGF를 oracle-guided serach probrem으로 설정하는 complexity-theoritic framwork를 제시
- input space에 대한 feedback (ex distance)를 oracle에게 물어본다.
- target에 도달하는 input을 찾기 위한 oracle query의 수를 performance metric으로 사용
- 가능한 input의 수의 log scale에 해당하는 알고리즘을 구현하고 최적임을 증명
- *MC2*에 이를 구현
# 1. Introduction
- 기존에는 CFG distance, branch constraint distance을 사용
- 이는 직관이나 경험적 증거 (학문적 분석이 없음)
- computational complexitytheoretic framework 제시
# 1.1. Complexity-Theoretic Framework
- DGF의 complexity-theoretic formulation를 제시
- instrumentation type및 fuzzing algorithm 에 대한 세부 사항을 추상화 하여 framwork로 전환
- DGF -> oracle-guided serach problem으로 모델링
- oracle은 serach space에 대한 정보를 fuzzing algorithm에게 알려주어 target reached input을 찾음
- 프로그램의 동작이나 input/ouput 분포에 대한 가정을 하지 않음
- oralce이 쿼리당 크지만 일정한 양의 정보를 가진 내용을 반환하도록함
## 1.2. Execution Complexity
- target site에 도달할때까지 oralce에게 보내는 쿼리의 수로 performance 를 측정
- 우리의 complexity metric은 oracle을 통해 quantum algorithm의 quantum 부분과 classical part를 분리함

- query complexity : 어떤 알고리즘이 주어진 문제를 해결하기 위하여 얼마나 많은은 질문을 해야 하는가 > 이를 이용하여 알고리즘의 하한선을 정할 수 있고 얼마나 효율적인지 정량적으로 평가할 수 있다.

[On Quantum Versus Classical Query Complexity](https://eccc.weizmann.ac.il/report/2021/115/)


> 단 하나도 이해하지 못하였다.


[Understanding Quantum Algorithms via Query Complexity](https://eta.impa.br/dl/043.pdf)

> 양자 알고리즘이 무엇인지 설명

- feedback information에 대한 lower bound를 탐구하여 이를 최대한 활용하는 adaptive algorithm을 설계하는 방법을 사용함

## 1.3. An Optimal Fuzzing Algorithm
- *noisy counting oracle*을 도입함
- 이는 두 input space를 에서 각 영역에서 target site로 도달하는 입력을 대략적으로 계산하고 더 높은 수를 가진 영역이 더 유망한것으로 판단하고 이를 반환한다. (p<0.5의 확률로 거짓을 반환하는 Monte Carlo counting algorithm)

시간 복잡도 : $O({{log(N)} \over {(0.5-p)^2}})$ > 이는 다른 알고리즘으로 계선될 수 없음을 증명

- 우리의 fuzzing algorithm은 더 높은 수의 영역을 선택하고 Binary search 로 유망한 영역을 좁혀가는 counting oracle을 사용
- 하지만 어떤 input space가 더 큰 수를 가지고 있는지 확신할 수 없기 때문에 이러한 noise에 강해야 한다.
- 따라서 noisy binary search algorithm을 사용하였다.
- 각 space에 가중치 집합을 사용하여 알고리즘의 정확도를 나타낸다. > 즉 원하는 input이 해당 영역에 존재할 가능성을 나타냄
- 알고리즘은 각 oracle query에 기반하여 유망한 영역의 가중치를 반복적으로 증가시키며 유망한 input sapce를 좁혀나간다.

## 1.4. Approximate Counting with Monte Carlo
-  noisy counting oracle을 구현하기위하여 Monte Carlo algorithm 사용
- Monte Carlo random sampling은 실제 값이 0이 아닌 작은 수이더라도 대부분의 근사 계산이 0이 될 수 있다.
- input space에서 target reach input의 수를 계산하는 것도 매우 작은 확률이기에 0으로 계산된다.
- 이 문제를 극복하기 위해 우리는 목표에 도달할 수 있는 input을 찾지 못하더라도 더 높은 확신을 가지고 계산에 대한 상한선을 계산할 수 있다는것을 관찰하였다.
## 1.5. Concentration Bounds
- concentration bound를 이용함 > 평균과 분산에 기반하여 랜덤 함수가 특정 값을 가질 확률의 상한을 정하는 방법
- branch constraint의 distance를 기반으로 모델링 하면 무작위로 선택된 입력으로 평균과 분산을 계산하면 이 branch를 만족할 가능성에 대한 상한을 구할 수 있다.
하지만 이는 over approximate를 일으킬 수 있다. > 이를 방지하기 위하여 단일 oracle query를 수행할때 어떤 input에 대해서도 만족된적 없는 branch에 대해서만 상한을 적용한다. 나머지에 대해서는 branch를 만족시키는 input의 수와 총 입력수의 경험직 비율을 사용함
## 1.6. Counting along Multiple Branches
- 

## 1.7. contributions

# 2. Methodology


## 2.1. Terminology and Notation

## 2.2. A Framework for Directed Greybox Fuzzing

## 2.3. Optimal Directed Fuzzer with Noisy Counting Oracle

## 2.4. Noisy Counting Oracle through Monte Carlo Counting

# 3. Implementation

# 4. Evaluation

## 4.1. RQ1: Fuzzers Comparison

## 4.2. RQ2: Bug Finding

## 4.3. RQ3: Performance Overhead

## 4.4. RQ4: Design Choices

# 5. Related Work

# 6. Conclusion