[MC2: Rigorous and Effeicient Directed Greybox Fuzzing](https://arxiv.org/pdf/2208.14530.pdf)
# Abstract
- 기존 DGF는 performance나 optimality에 대한 이론적 분석을 제공하지 않음
- DGF를 oracle-guided serach probrem으로 설정하는 complexity-theoritic framwork를 제시
- input space에 대한 feedback (ex distance)를 oracle에게 물어본다.
- target에 도달하는 input을 찾기 위한 oracle query의 수를 performance metric으로 사용
- 가능한 input의 수의 log scale에 해당하는 알고리즘을 구현하고 최적임을 증명
- *MC2*에 이를 구현
# 1. Introduction
- 기존에는 CFG distance, branch constraint distance을 사용
- 이는 직관이나 경험적 증거 (학문적 분석이 없음)
- computational complexitytheoretic framework 제시
# 1.1. Complexity-Theoretic Framework
- DGF의 complexity-theoretic formulation를 제시
- instrumentation type및 fuzzing algorithm 에 대한 세부 사항을 추상화 하여 framwork로 전환
- DGF -> oracle-guided serach problem으로 모델링
- oracle은 serach space에 대한 정보를 fuzzing algorithm에게 알려주어 target reached input을 찾음
- 프로그램의 동작이나 input/ouput 분포에 대한 가정을 하지 않음
- oralce이 쿼리당 크지만 일정한 양의 정보를 가진 내용을 반환하도록함
## 1.2. Execution Complexity
- target site에 도달할때까지 oralce에게 보내는 쿼리의 수로 performance 를 측정
- 우리의 complexity metric은 oracle을 통해 quantum algorithm의 quantum 부분과 classical part를 분리함

- query complexity : 어떤 알고리즘이 주어진 문제를 해결하기 위하여 얼마나 많은은 질문을 해야 하는가 > 이를 이용하여 알고리즘의 하한선을 정할 수 있고 얼마나 효율적인지 정량적으로 평가할 수 있다.

[On Quantum Versus Classical Query Complexity](https://eccc.weizmann.ac.il/report/2021/115/)


> 단 하나도 이해하지 못하였다.


[Understanding Quantum Algorithms via Query Complexity](https://eta.impa.br/dl/043.pdf)

> 양자 알고리즘이 무엇인지 설명

- feedback information에 대한 lower bound를 탐구하여 이를 최대한 활용하는 adaptive algorithm을 설계하는 방법을 사용함

## 1.3. An Optimal Fuzzing Algorithm
- *noisy counting oracle*을 도입함
- 이는 두 input space를 에서 각 영역에서 target site로 도달하는 입력을 대략적으로 계산하고 더 높은 수를 가진 영역이 더 유망한것으로 판단하고 이를 반환한다. (p<0.5의 확률로 거짓을 반환하는 Monte Carlo counting algorithm)

시간 복잡도 : $O({{log(N)} \over {(0.5-p)^2}})$ > 이는 다른 알고리즘으로 계선될 수 없음을 증명

- 우리의 fuzzing algorithm은 더 높은 수의 영역을 선택하고 Binary search 로 유망한 영역을 좁혀가는 counting oracle을 사용
- 하지만 어떤 input space가 더 큰 수를 가지고 있는지 확신할 수 없기 때문에 이러한 noise에 강해야 한다.
- 따라서 noisy binary search algorithm을 사용하였다.
- 각 space에 가중치 집합을 사용하여 알고리즘의 정확도를 나타낸다. > 즉 원하는 input이 해당 영역에 존재할 가능성을 나타냄
- 알고리즘은 각 oracle query에 기반하여 유망한 영역의 가중치를 반복적으로 증가시키며 유망한 input sapce를 좁혀나간다.

## 1.4. Approximate Counting with Monte Carlo
-  noisy counting oracle을 구현하기위하여 Monte Carlo algorithm 사용
- Monte Carlo random sampling은 실제 값이 0이 아닌 작은 수이더라도 대부분의 근사 계산이 0이 될 수 있다.
- input space에서 target reach input의 수를 계산하는 것도 매우 작은 확률이기에 0으로 계산된다.
- 이 문제를 극복하기 위해 우리는 목표에 도달할 수 있는 input을 찾지 못하더라도 더 높은 확신을 가지고 계산에 대한 상한선을 계산할 수 있다는것을 관찰하였다.
## 1.5. Concentration Bounds
- concentration bound를 이용함 > 평균과 분산에 기반하여 랜덤 함수가 특정 값을 가질 확률의 상한을 정하는 방법
- branch constraint의 distance를 기반으로 모델링 하면 무작위로 선택된 입력으로 평균과 분산을 계산하면 이 branch를 만족할 가능성에 대한 상한을 구할 수 있다.
하지만 이는 over approximate를 일으킬 수 있다. > 이를 방지하기 위하여 단일 oracle query를 수행할때 어떤 input에 대해서도 만족된적 없는 branch에 대해서만 상한을 적용한다. 나머지에 대해서는 branch를 만족시키는 input의 수와 총 입력수의 경험직 비율을 사용함
## 1.6. Counting along Multiple Branches
- 각 branch를 만족사는 input의 수를 근사하고 이를 통해 목표에 도달하는 입력에 수에 대한 추정치를 얻는다. [2.4절](#24-noisy-counting-oracle-through-monte-carlo-counting)
- Monte Carlo Executionn : runtime에 control flow를 수정하여 외부 branch constraint를 만족하지 않더라도 내부 branch에 방문하도록 함
- 이를 통해 소수의 프로그램 실행으로 근사할 수 있음
- MC2(Monte Carlo Counting)을 구현함

![figure1](./image//11_figure1.png)

## 1.7. contributions
- DGF를 oracle-guided serach problem으로 정의하는 complexity-theoretic framework를 소개, 알고리즘의 성능을 측정하는 metric인 execution complexity를 도입함
- 가능한 input의 수에 logarithmic한 execution complexity를 갖는 DGF를 설계하였다.
- noisy counting oracle을 구현하기 위한 Monte Carlo algorithm을 구현

# 2. Methodology
## 2.1. Terminology and Notation
- fuzzer = DGF
- P = target program
- I = 유한한 input space 
- |·| = cardinality
### 2.1.1. Input Region
- WLOG. target program's input space = hyperrectangle I = [0,255]^d, d는 input byte
### 2.1.2. Control Flow Graph
- CFG=(V, E), V = BB, E = control-flow transition (ex branch)
- path $\pi$ = finite sequence of edge int CFG $\pi$ : $E_0 \rightarrow  E_1 \rightarrow ... \rightarrow E_k $
- 우리는$E_T \sub E $에 도달하는것에 관심이 있기 때문에 $\pi \Pi$
### 2.1.3. Program Execution
### 2.1.4. Branch Constraint
## 2.2. A Framework for Directed Greybox Fuzzing

### 2.2.1. Fuzzing as Oracle-Guided Search
### 2.2.2. Problem Definition
### 2.2.3. Execution Complexity
### 2.2.4. Greybox vs Blackbox Oracle
## 2.3. Optimal Directed Fuzzer with Noisy Counting Oracle
### 2.3.1. Noisy Counting Oracle
### 2.3.2. Optimal Deterministic Fuzzer
### 2.3.3. Optimal Randomized Fuzzer
## 2.4. Noisy Counting Oracle through Monte Carlo Counting
### 2.4.1. Monte Carlo Counting
### 2.4.2. Exploiting CFG Structure for Counting
### 2.4.3. Approximating Path Counts
### 2.4.4. Uniconstraint Counts
### 2.4.5. Challenges in Approximating Uniconstraint Counts
### 2.4.6. C1: Handling Evaluated but Unsatisifed Branches
### 2.4.7. C2: Handling Unevaluated Nested Branches
# 3. Implementation
## 3.1. Toolchain
## 3.2. Reducing Loop Overheads
## 3.3. Assigning A Total Order
## 3.4. Preprocessing
## 3.5. Randomly Generating Inputs
# 4. Evaluation

## 4.1. RQ1: Fuzzers Comparison
### 4.1.1. Tested Benchmarks
### 4.1.2. Baseline Fuzzers
### 4.1.3. Experimental Setup
### 4.1.4. Magma Results
### 4.1.5. Case Study
### 4.1.6. Fuzzer Test Suite Results

> Result

## 4.2. RQ2: Bug Finding

> Result

## 4.3. RQ3: Performance Overhead

> Result

## 4.4. RQ4: Design Choices

> Result

# 5. Related Work
## 5.1. Approximate Counting
## 5.2. Directed Greybox Fuzzing
# 6. Conclusion