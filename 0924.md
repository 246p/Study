# TODO
- patch 검증 (debugging, bug type check)
- ASAN Option 설정 (traige, fuzzing)
- test.sh > binary 검증
- commit 정리
- malloc hoocking
# CVE
- NON-MAGMA : 모든 bug에 대해서 ASAN ON (Trigger 되지 않는 경우가 많음)
- BEACON : ASAN을 켜면 build 불가능
- `ASAN_OPTIONS=abort_on_error=1:symbolize=0:detect_leaks=0`
## test
- sh
``` sh
#!/bin/bash

results_dir="results"
rm -rf "$results_dir"
mkdir -p "$results_dir"
export ASAN_OPTIONS=detect_leaks=0
binary_dirs=("vanilla")
poc_dir="poc"
timeout_duration=10

run_binary() {
    local binary="$1"
    local poc="$2"
    local output_file="$3"
    local cmdline=""
    local exit_code
    local status=""

    case "$(basename "$binary")" in
        swftophp*) cmdline="$binary $poc" ;;
        readelf*) cmdline="$binary -a \"$poc\"" ;;
        cxxfilt*) cmdline="$binary < \"$poc\"" ;;
        lrzip*) cmdline="$binary -t \"$poc\"" ;;
        *) 
            echo "Unknown binary type: $(basename "$binary")" | tee -a "$output_file"
            status="ER"
            echo "ASAN_OPTIONS=detect_leaks=0 $cmdline $status" | tee -a "$output_file"
            return 1
            ;;
    esac
    timeout $timeout_duration bash -c "$cmdline" < /dev/null > "$output_file" 2>&1
    exit_code=$?
    if [ $exit_code -eq 124 ]; then
        status="TO"
    else
        if grep -q "Sanitizer" "$output_file"; then
            status="ER"
        else
            status="SU"
        fi
    fi
    echo "ASAN_OPTIONS=detect_leaks=0 $cmdline $status" | tee -a "$output_file"
    return $exit_code
}

# PoC 파일 설정 함수
get_poc_files() {
    local binary_name="$1"
    case "$binary_name" in
        swftophp*) find "$poc_dir/libming-4.7" -type f ;;
        readelf*) find "$poc_dir/binutils-2.31" -type f ;;
        cxxfilt*) find "$poc_dir/binutils-2.26" -type f ;;
        lrzip*) find "$poc_dir/lrzip-9de7ccb" "$poc_dir/lrzip-ed51e1" -type f ;;
        *) echo "" ;;
    esac
}

# 바이너리 실행 루프
for dir in "${binary_dirs[@]}"; do
    for binary in bin/$dir/*; do
        binary_name=$(basename "$binary")
        poc_files=$(get_poc_files "$binary_name")
        for poc in $poc_files; do
            output_file="$results_dir/${dir}_${binary_name}_$(basename "$poc").log"
            run_binary "$binary" "$poc" "$output_file"
        done
    done
done
```
- parse
``` sh
#!/bin/bash
LOG_FILE="${1:-a.log}"

if [ ! -f "$LOG_FILE" ]; then
    echo "Error: Log file '$LOG_FILE' not found!"
    exit 1
fi

awk '
{
    match($0, /bin\/[^\/]+\/([^ ]+)/, arr1)
    binary = arr1[1]
    if (match($0, /"poc\/[^\/]+\/([^"]+)"/, arr2)) {
        poc = arr2[1]
    }
    else if (match($0, /poc\/[^\/]+\/([^ ]+)/, arr3)) {
        poc = arr3[1]
    }
    else {
        poc = ""
    }
    match($0, /(SU|ER|TO)$/, arr4)
    status = arr4[1]
    if (binary && poc && status) {
        if (status == "SU") {
            su[binary] = su[binary] ? su[binary] " " poc : poc
        }
        else if (status == "ER") {
            er[binary] = er[binary] ? er[binary] " " poc : poc
        }
        else if (status == "TO") {
            to[binary] = to[binary] ? to[binary] " " poc : poc
        }
    }
}
END {
    for (binary in su) { binaries[binary] = 1 }
    for (binary in er) { binaries[binary] = 1 }
    for (binary in to) { binaries[binary] = 1 }

    for (binary in binaries) {
        print "binary : " binary
        if (binary in su) {
            print "SU : " su[binary]
        } else {
            print "SU : -"
        }
        if (binary in er) {
            print "ER : " er[binary]
        } else {
            print "ER : -"
        }
        if (binary in to) {
            print "TO : " to[binary]
        } else {
            print "TO : -"
        }
        print ""
    }
}
' "$LOG_FILE"

```
- log
``` log
binary : swftophp-201711729
SU : 201711729
ER : 20169829 20169827 20169831 201711728
TO : 20179988-repro 20179988-github

binary : swftophp-20169831
SU : -
ER : 20169829 201711729 20169827 201711728
TO : 20179988-repro 20169831 20179988-github

binary : lrzip_9-20178846
SU : 20178846
ER : 201811496
TO : -

binary : lrzip_e-201811496
SU : 20178846 201811496
ER : -
TO : -

binary : cxxfilt-20164487
SU : 20164487-a 20164487-b
ER : 20164489 20164492-case2 20164490 20164492-case1 20164492-case3
TO : -

binary : swftophp-common
SU : -
ER : 20169829 201711729 20169827 20169831 201711728
TO : 20179988-repro 20179988-github

binary : lrzip_9-common
SU : -
ER : 20178846 201811496
TO : -

binary : cxxfilt-20164489
SU : 20164489
ER : 20164487-a 20164487-b 20164492-case2 20164490 20164492-case1 20164492-case3
TO : -

binary : lrzip_e-common
SU : 20178846
ER : 201811496
TO : -

binary : swftophp-20169827
SU : -
ER : 20169829 201711729 20169831 201711728
TO : 20169827 20179988-repro 20179988-github

binary : readelf-common
SU : -
ER : 201820623
TO : -

binary : swftophp-20169829
SU : 20169829
ER : 201711729 20169827 20169831 201711728
TO : 20179988-repro 20179988-github

binary : cxxfilt-common
SU : -
ER : 20164487-a 20164489 20164487-b 20164492-case2 20164490 20164492-case1 20164492-case3
TO : -

binary : cxxfilt-20164490
SU : 20164490
ER : 20164487-a 20164489 20164487-b 20164492-case2 20164492-case1 20164492-case3
TO : -

binary : swftophp-201711728
SU : -
ER : 20169829 201711729 20169827 20169831 201711728
TO : 20179988-repro 20179988-github

binary : swftophp-20179988
SU : -
ER : 20169829 201711729 20169827 20169831 201711728
TO : 20179988-repro 20179988-github

binary : cxxfilt-20164492
SU : 20164492-case2 20164492-case1 20164492-case3
ER : 20164487-a 20164489 20164487-b 20164490
TO : -

binary : readelf-201820623
SU : 201820623
ER : -
TO : -


```
- 검토 필요
## cxxfilt
### 2016-4487 - ND
### 2016-4489 - IOF
### 2016-4490 - IOF
### 2016-4492 - BOF
## swftophp
### 2016-9827 - BOF
### 2016-9829 - BOF
### 2016-9831 - BOF
### 2017-9988 - ND
- crash가 아닌 timeout (trigger 되지 않음)
### 2017-11728 - BOF
### 2017-11729 - BOF
## lrzip
### 2017-8846 : UAF
```c
i64 read_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)
{
	struct stream_info *sinfo = ss;
	i64 ret = 0;

	while (len) {
		i64 n;

		n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);
		printf("read_stream : %p\n", sinfo->s[streamno].buf);
		if (n > 0) {
			memcpy(p, sinfo->s[streamno].buf + sinfo->s[streamno].bufp, n);
			sinfo->s[streamno].bufp += n;
			p += n;
			len -= n;
			ret += n;
		}

		if (len && sinfo->s[streamno].bufp == sinfo->s[streamno].buflen) {
			if (unlikely(fill_buffer(control, sinfo, streamno)))
				return -1;
			if (sinfo->s[streamno].bufp == sinfo->s[streamno].buflen)
				break;
		}
	}

	return ret;
}
/* fill a buffer from a stream - return -1 on failure */
static int fill_buffer(rzip_control *control, struct stream_info *sinfo, int streamno)
{
	printf("fill_buffer 1  : %p\n", s->buf);
	if (s->buf)
		free(s->buf);
	...
	s->buf = ucthread[s->unext_thread].s_buf;
    ...
	printf("fill_buffer 2  : %p\n", s->buf);
	return 0;
}
```

``` log
read_stream    : (nil)
fill_buffer 1  : (nil)
fill_buffer 2  : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : (nil)
fill_buffer 1  : (nil)
fill_buffer 2  : 0x62100000f100
read_stream    : 0x62100000f100
fill_buffer 1  : 0x62100000f100
fill_buffer 2  : 0x621000010500
read_stream    : 0x621000010500
fill_buffer 1  : 0x621000010500
fill_buffer 2  : 0x621000011900
read_stream    : 0x621000011900
fill_buffer 1  : 0x621000011900
fill_buffer 2  : 0x621000012d00
read_stream    : 0x621000012d00
fill_buffer 1  : 0x621000012d00
fill_buffer 2  : 0x621000014100
read_stream    : 0x621000014100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
fill_buffer 1  : 0x621000000100
fill_buffer 2  : 0x621000000100
read_stream    : 0x621000000100
```


### 2018-11496 : UAF
``` log
read_stream    : (nil)
fill_buffer 1  : (nil)
fill_buffer 2  : 0x602000000030
read_stream    : 0x602000000030
read_stream    : 0x602000000030
fill_buffer 1  : 0x602000000030
fill_buffer 2  : 0x602000000030
read_stream    : 0x602000000030
```
## readelf
### 2018-20623 : UAF
# malloc hoocking
- user code
```c
#include <stdio.h>
#include <stdlib.h>

int main (){
    int *p = (int *)malloc(sizeof(int));
    int *q = (int *)calloc(sizeof(int), 2);
    p = realloc(p, sizeof(int) * 8);
    free(p);
    free(q);
    int *r = (int *)malloc(sizeof(int)* 2); // r == q
    free(r);
    return 0;
}
```
## glibc
- glibc 2.33 이하에서 가능 (dfuzz-exp : 2.31)
- ASAN이 자체적으로 hoocking 하기 때문에 문제가 생김
- 이는 windranger, Beacon과 같이 build.sh가 아닌 llvm pass를 중간에 자르고 다시 재사용할때 유용한 방법 
### test code
- shared library
``` sh
#!/bin/bash
set -x
rm dfuzz_hook.so test
clang -shared -fPIC hook.c -o dfuzz_hook.so
clang test.c ./dfuzz_hook.so -o test -ldl
# clang test.c ./dfuzz_hook.so -o test -ldl -fsanitize=address
./test
rm dfuzz_hook.so test
```
- archive library
``` sh
#!/bin/bash
rm dfuzz_hook.o dfuzz_hook.a test
set -x
clang -c hook.c -o dfuzz_hook.o
ar rcs dfuzz_hook.a dfuzz_hook.o
clang test.c ./dfuzz_hook.a -o test -ldl
# clang test.c ./dfuzz_hook.a -o test -ldl -fsanitize=address
./test
rm dfuzz_hook.o dfuzz_hook.a test
```
- hook.c
``` c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

static void* (*real_malloc)(size_t) = NULL;
static void (*real_free)(void*) = NULL;
static void* (*real_calloc)(size_t, size_t) = NULL;
static void* (*real_realloc)(void*, size_t) = NULL;

static int is_initialized = 0;

static void init_real_functions() {
    if (!is_initialized) {
        real_malloc = dlsym(RTLD_NEXT, "malloc");
        real_free = dlsym(RTLD_NEXT, "free");
        real_calloc = dlsym(RTLD_NEXT, "calloc");
        real_realloc = dlsym(RTLD_NEXT, "realloc");
        is_initialized = 1;
    }
}

static void log_allocation(const char* func, void* ptr, size_t size) {
    char buf[256];
    int len = snprintf(buf, sizeof(buf), "%s: %p, size: %zu\n", func, ptr, size);
    write(STDOUT_FILENO, buf, len);
}

void* malloc(size_t size) {
    init_real_functions();
    void* ptr = real_malloc(size);
    log_allocation("dfuzz : Malloc", ptr, size);
    return ptr;
}

void free(void* ptr) {
    init_real_functions();
    log_allocation("dfuzz : Free", ptr, 0);
    real_free(ptr);
}

void* calloc(size_t nmemb, size_t size) {
    init_real_functions();
    void* ptr = real_calloc(nmemb, size);
    log_allocation("dfuzz : Calloc", ptr, nmemb * size);
    return ptr;
}

void* realloc(void* ptr, size_t size) {
    init_real_functions();
    void* new_ptr = real_realloc(ptr, size);
    char buf[256];
    int len = snprintf(buf, sizeof(buf), "dfuzz : Realloc: old %p, new %p, size: %zu\n", ptr, new_ptr, size);
    write(STDOUT_FILENO, buf, len);
    return new_ptr;
}

```
- 실행 결과
``` log
dfuzz : Malloc: 0x23e72a0, size: 4
dfuzz : Calloc: 0x23e72c0, size: 8
dfuzz : Realloc: old 0x23e72a0, new 0x23e72a0, size: 8
dfuzz : Free: 0x23e72a0, size: 0
dfuzz : Free: 0x23e72c0, size: 0
dfuzz : Malloc: 0x23e72c0, size: 8
dfuzz : Free: 0x23e72c0, size: 0
```

## llvm pass
- malloc, free hoocking 하여 memmory tracking(address, size)
- object file : magma.o 처럼 LD flag같은 요소 추가
- Iibc, llvm 모두 해보기

## ASAN api 사용
```c
#include <sanitizer/asan_interface.h>
__asan_get_alloc_stack(void *addr, void **trace, size_t size, int *thread_id);
__asan_get_free_stack(void *addr, void **trace, size_t size, int *thread_id);
void __asan_get_statistics(void *stat);
bool __asan_address_is_poisoned(void const volatile *addr);
```