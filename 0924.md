# Triage 수정 (split)
- 실제 binary 이름과 output binary 이름이 다른 경우
- triage 실행시 ASAN option 적용
# CVE
- fuzzer별 build, bug type check, patch 작성
- NON-MAGMA : 모든 bug에 대해서 ASAN ON (Trigger 되지 않는 경우가 많음)
- BEACON : ASAN을 켜면 build 불가능
``` sh
root@b9195d793d42:/benchmark/temp# /fuzzer/Beacon/precondInfer ./swftophp.bc --target-file=/benchmark/target/swftophp/20169827 --join-bound=5
precondInfer: /build/SVF/include/MemoryModel/PAG.h:524: NodeID PAG::addObjNode(const llvm::Value*, NodeID): Assertion `mem->getSymId() == i && "not same object id?"' failed.
Aborted (core dumped)
```
## cxxfilt
### 2016-4487 - ND
### 2016-4489 - IOF
### 2016-4490 - IOF
### 2016-4492 - BOF
## swftophp
### 2016-9827 - BOF
### 2016-9829 - BOF
### 2016-9831 - BOF
### 2017-9988 - ND
- crash가 아닌 timeout (trigger 되지 않음)
### 2017-11728 - BOF
### 2017-11729 - BOF
## lrzip
### 2017-8846 : UAF
```c
i64 read_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)
{
	struct stream_info *sinfo = ss;
	i64 ret = 0;

	while (len) {
		i64 n;

		n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);
		printf("read_stream : %p\n", sinfo->s[streamno].buf);
		if (n > 0) {
			memcpy(p, sinfo->s[streamno].buf + sinfo->s[streamno].bufp, n);
			sinfo->s[streamno].bufp += n;
			p += n;
			len -= n;
			ret += n;
		}

		if (len && sinfo->s[streamno].bufp == sinfo->s[streamno].buflen) {
			if (unlikely(fill_buffer(control, sinfo, streamno)))
				return -1;
			if (sinfo->s[streamno].bufp == sinfo->s[streamno].buflen)
				break;
		}
	}

	return ret;
}
/* fill a buffer from a stream - return -1 on failure */
static int fill_buffer(rzip_control *control, struct stream_info *sinfo, int streamno)
{
	printf("fill_buffer 1  : %p\n", s->buf);
	if (s->buf)
		free(s->buf);
	...
	s->buf = ucthread[s->unext_thread].s_buf;
    ...
	printf("fill_buffer 2  : %p\n", s->buf);
	return 0;
}
```

``` log
read_stream    : (nil)
fill_buffer 1  : (nil)
fill_buffer 2  : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : (nil)
fill_buffer 1  : (nil)
fill_buffer 2  : 0x62100000f100
read_stream    : 0x62100000f100
fill_buffer 1  : 0x62100000f100
fill_buffer 2  : 0x621000010500
read_stream    : 0x621000010500
fill_buffer 1  : 0x621000010500
fill_buffer 2  : 0x621000011900
read_stream    : 0x621000011900
fill_buffer 1  : 0x621000011900
fill_buffer 2  : 0x621000012d00
read_stream    : 0x621000012d00
fill_buffer 1  : 0x621000012d00
fill_buffer 2  : 0x621000014100
read_stream    : 0x621000014100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
read_stream    : 0x621000000100
fill_buffer 1  : 0x621000000100
fill_buffer 2  : 0x621000000100
read_stream    : 0x621000000100
```


### 2018-11496 : UAF
``` log
read_stream    : (nil)
fill_buffer 1  : (nil)
fill_buffer 2  : 0x602000000030
read_stream    : 0x602000000030
read_stream    : 0x602000000030
fill_buffer 1  : 0x602000000030
fill_buffer 2  : 0x602000000030
read_stream    : 0x602000000030
```
## readelf
### 2018-20623 : UAF
# fuzzing script
- fuzzer script에 ASAN_OPTION 추가
# malloc hoocking
- user code
```c
#include <stdio.h>
#include <stdlib.h>

int main (){
    int *p = (int *)malloc(sizeof(int));
    int *q = (int *)calloc(sizeof(int), 2);
    p = realloc(p, sizeof(int) * 8);
    free(p);
    free(q);
    int *r = (int *)malloc(sizeof(int)* 2); // r == q
    free(r);
    return 0;
}
```
## glibc
- glibc 2.33 이하에서 가능 (dfuzz-exp : 2.31)
- ASAN이 자체적으로 hoocking 하기 때문에 문제가 생김
- 이는 windranger, Beacon과 같이 build.sh가 아닌 llvm pass를 중간에 자르고 다시 재사용할때 유용한 방법 
### test code
- shared library
``` sh
#!/bin/bash
set -x
rm dfuzz_hook.so test
clang -shared -fPIC hook.c -o dfuzz_hook.so
clang test.c ./dfuzz_hook.so -o test -ldl
# clang test.c ./dfuzz_hook.so -o test -ldl -fsanitize=address
./test
rm dfuzz_hook.so test
```
- archive library
``` sh
#!/bin/bash
rm dfuzz_hook.o dfuzz_hook.a test
set -x
clang -c hook.c -o dfuzz_hook.o
ar rcs dfuzz_hook.a dfuzz_hook.o
clang test.c ./dfuzz_hook.a -o test -ldl
# clang test.c ./dfuzz_hook.a -o test -ldl -fsanitize=address
./test
rm dfuzz_hook.o dfuzz_hook.a test
```
- hook.c
``` c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

static void* (*real_malloc)(size_t) = NULL;
static void (*real_free)(void*) = NULL;
static void* (*real_calloc)(size_t, size_t) = NULL;
static void* (*real_realloc)(void*, size_t) = NULL;

static int is_initialized = 0;

static void init_real_functions() {
    if (!is_initialized) {
        real_malloc = dlsym(RTLD_NEXT, "malloc");
        real_free = dlsym(RTLD_NEXT, "free");
        real_calloc = dlsym(RTLD_NEXT, "calloc");
        real_realloc = dlsym(RTLD_NEXT, "realloc");
        is_initialized = 1;
    }
}

static void log_allocation(const char* func, void* ptr, size_t size) {
    char buf[256];
    int len = snprintf(buf, sizeof(buf), "%s: %p, size: %zu\n", func, ptr, size);
    write(STDOUT_FILENO, buf, len);
}

void* malloc(size_t size) {
    init_real_functions();
    void* ptr = real_malloc(size);
    log_allocation("dfuzz : Malloc", ptr, size);
    return ptr;
}

void free(void* ptr) {
    init_real_functions();
    log_allocation("dfuzz : Free", ptr, 0);
    real_free(ptr);
}

void* calloc(size_t nmemb, size_t size) {
    init_real_functions();
    void* ptr = real_calloc(nmemb, size);
    log_allocation("dfuzz : Calloc", ptr, nmemb * size);
    return ptr;
}

void* realloc(void* ptr, size_t size) {
    init_real_functions();
    void* new_ptr = real_realloc(ptr, size);
    char buf[256];
    int len = snprintf(buf, sizeof(buf), "dfuzz : Realloc: old %p, new %p, size: %zu\n", ptr, new_ptr, size);
    write(STDOUT_FILENO, buf, len);
    return new_ptr;
}

```
- 실행 결과
``` log
dfuzz : Malloc: 0x23e72a0, size: 4
dfuzz : Calloc: 0x23e72c0, size: 8
dfuzz : Realloc: old 0x23e72a0, new 0x23e72a0, size: 8
dfuzz : Free: 0x23e72a0, size: 0
dfuzz : Free: 0x23e72c0, size: 0
dfuzz : Malloc: 0x23e72c0, size: 8
dfuzz : Free: 0x23e72c0, size: 0
```

## llvm pass
- 
- malloc, free hoocking 하여 memmory tracking(address, size)
- object file : magma.o 처럼 LD flag같은 요소 추가
- Iibc, llvm 모두 해보기

## ASAN api 사용
```c
#include <sanitizer/asan_interface.h>
__asan_get_alloc_stack(void *addr, void **trace, size_t size, int *thread_id);
__asan_get_free_stack(void *addr, void **trace, size_t size, int *thread_id);
void __asan_get_statistics(void *stat);
bool __asan_address_is_poisoned(void const volatile *addr);
```