# refactoring
- windranger, Beacon에 대해서도 유사하게 refactoring후 commit
- `/workspace/libming-4.7`로 주었을때 gen_distance_orig.sh 실패
- 기존 방식을 유지해야함

# trigger 되지 않는 binary
## lrzip
- error log가 아닌 exit(0);
### CVE-2017-8846
- DAFL : N/A
```diff
--- a/runzip.orig	2024-09-10 10:29:45.319699629 +0000
+++ b/runzip.c	2024-09-10 10:30:05.503767537 +0000
@@ -219,7 +219,8 @@
 
 	while (len) {
 		n = MIN(len, offset);
-
+		if (unlikely(n < 1))
+			fprintf(stderr,"Failed fd history in unzip_match due to corrupt archive\n"); exit(0);
 		if (unlikely(read_fdhist(control, off_buf, (size_t)n) != (ssize_t)n)) {
 			free(buf);
 			fatal_return(("Failed to read %d bytes in unzip_match\n", n), -1);

--- a/stream.orig	2024-09-10 10:56:07.415526880 +0000
+++ b/stream.c	2024-09-10 10:56:37.735161557 +0000
@@ -1570,10 +1570,10 @@
 	stream_thread_struct *st;
 	uchar c_type, *s_buf;
 
-	if (s->buf)
-		free(s->buf);
 	if (s->eos)
 		goto out;
+	if (s->buf)
+		free(s->buf);
 fill_another:
 	if (unlikely(ucthread[s->uthread_no].busy))
 		failure_return(("Trying to start a busy thread, this shouldn't happen!\n"), -1);
```
### CVE-2018-11496
- DAFL : 4s
``` diff
--- a/lrzip.orig	2024-09-10 10:29:45.319699629 +0000
+++ b/lrzip.c	2024-09-10 10:30:05.503767537 +0000
@@ -803,6 +803,8 @@
 	if (!STDIN) {
 		if (unlikely(!read_magic(control, fd_in, &expected_size)))
 			return false;
+		if (unlikely(expected_size < 0))
+			fprintf(stderr,"Invalid expected size %lld\n", expected_size); exit(0);
 	}
 
 	if (!STDOUT && !TEST_ONLY) {

```

## swftophp
### CVE-2018-9132 > trigger 성공
- DAFL: 2058s
# crash가 발생하지 않는 binary
## readelf
### CVE-2018-20623 > trigger 성공
- patch file 변경
- error > fprintf(stderr, ~~)
- exit(0) 추가
``` diff
--- binutils/readelf.orig	2024-09-08 18:08:44.636561170 +0000
+++ binutils/readelf.c	2024-09-08 18:10:57.390608239 +0000
@@ -19052,7 +19052,7 @@
       /* Read the next archive header.  */
       if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
         {
-          error (_("%s: failed to seek to next archive header\n"), filedata->file_name);
+          fprintf(stderr, "%s: failed to seek to next archive header\n", arch.file_name); exit(0);
           return FALSE;
         }
       got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
@@ -19060,7 +19060,7 @@
         {
           if (got == 0)
 	    break;
-          error (_("%s: failed to read archive header\n"), filedata->file_name);
+          fprintf(stderr, "%s: failed to read archive header\n", arch.file_name); exit(0);
           ret = FALSE;
           break;
         }
@@ -19080,7 +19080,7 @@
       name = get_archive_member_name (&arch, &nested_arch);
       if (name == NULL)
 	{
-	  error (_("%s: bad archive file name\n"), filedata->file_name);
+   fprintf(stderr, "%s: bad archive file name\n", arch.file_name); exit(0);
 	  ret = FALSE;
 	  break;
 	}
@@ -19089,7 +19089,7 @@
       qualified_name = make_qualified_name (&arch, &nested_arch, name);
       if (qualified_name == NULL)
 	{
-	  error (_("%s: bad archive file name\n"), filedata->file_name);
+	  fprintf(stderr, "%s: bad archive file name\n", arch.file_name); exit(0);
 	  ret = FALSE;
 	  break;
 	}
@@ -19135,7 +19135,7 @@
 	  if (nested_arch.file == NULL)
 	    {
- 	     error (_("%s: contains corrupt thin archive: %s\n"),
-		     filedata->file_name, name);
+        fprintf(stderr, "%s: contains corrupt thin archive: %s\n", 
+		     qualified_name, name); exit(0);
 	      ret = FALSE;
 	      break;
 	    }
```
# malloc hooking
- `#define malloc dfuzz_malloc` < 과 같은 code를 모든 source file 최상단에 선언 (preprocessing 시 처리될것)
- 해당 부분을 정적 라이브러리로 구현하여 hooking 
## build 방법
### magma
- libpng : autoreconf -> configure -> make
- libtiff : autogen -> configure -> make
- libxml2 : autogen -> make
### non-magma
- binutils : configure make
- libming : autogen -> configure -> make
- lrzip : autogen -> configure -> make

# 매크로 추가
``` sh
#!/bin/bash
if [ $# -ne 1 ]
then
    echo "usage: $0 <path>"
    exit 1
fi

TARGET_PATH=$1

find "$TARGET_PATH" -type f -name "*.c" | while read file; do
  sed -i "1i\\
#define malloc dfuzz_malloc\\
#define realloc dfuzz_realloc\\
#define free dfuzz_free\\
#define calloc dfuzz_calloc" "$file"
done

```
## test - libming
- dfuzz_hook.c
``` c
#include <stdio.h>
#include <stdlib.h>

void* dfuzz_malloc(size_t size) {
    void* ptr = malloc(size);
    printf("dfuzz_malloc(%zu) = %p\n", size, ptr);
    return ptr;
}

void* dfuzz_realloc(void* ptr, size_t size) {
    void* new_ptr = realloc(ptr, size);
    printf("dfuzz_realloc(%p, %zu) = %p\n", ptr, size, new_ptr);
    return new_ptr;
}

void dfuzz_free(void* ptr) {
    printf("dfuzz_free(%p)\n", ptr);
    free(ptr);
}

void* dfuzz_calloc(size_t nmemb, size_t size) {
    void* ptr = calloc(nmemb, size);
    printf("dfuzz_calloc(%zu, %zu) = %p\n", nmemb, size, ptr);
    return ptr;
}
```
- sh
``` sh
clang -c dfuzz_hook.c
ar rcs libdfuzz_hook.a dfuzz_hook.o

CC=clang
CFLAGS="-g -fsanitize=address -ldl"

```
- build.sh 수정
``` sh
#!/bin/bash

SRC_DIR="/workspace/libming-4.7"
GIT_URL="https://github.com/libming/libming.git"
TAG_NAME="ming-0_4_7"

rm -rf /build_output/*
rm -rf $SRC_DIR

git clone $GIT_URL $SRC_DIR || exit 1
cd $SRC_DIR || exit 1
git checkout $TAG_NAME || exit 1
if [ $# -eq 1 ]; then
  patch -p2 < $1
fi

/test/define.sh /workspace/libming-4.7 # 추가

export CFLAGS="-fcommon $CFLAGS"
export CXXFLAGS="-fcommon $CXXFLAGS"
./autogen.sh && ./configure --disable-shared --disable-freetype
make || exit 1
cp util/swftophp /build_output/ || exit 1


```

- build script (LIBMING)
``` sh
#!/bin/bash
set -x
source /magma/magma/setup_magma.sh
source /benchmark/build_bench_common.sh

clang -c /test/dfuzz_hook.c -fPIC -o /magma_out/dfuzz_hook.o

export CC="clang"
export CXX="clang++"
export LIBS="/magma_out/dfuzz_hook.o $LIBS"

mkdir -p /benchmark/bin/vanilla
build_project "libming-4.7" "ASAN"
copy_binary "vanilla" "swftophp" "common"

```
- 결과
```
header indicates a filesize of 3313068799 but filesize is 165
<?php
$m = new SWFMovie(128);

ming_setscale(1.0);
$m->setRate(142.777344);
$m->setDimension(-1152, 9107696);

/* Note: xMin and/or yMin are not 0! */

$m->setFrames(2696);
dfuzz_calloc(1, 264) = 0x612000000040
dfuzz_malloc(24) = 0x603000000010
/*Unknown block type 67*/
dfuzz_free(0x612000000040)
dfuzz_calloc(1, 264) = 0x6120000001c0
dfuzz_malloc(1) = 0x602000000010

/* SWF_PROTECT */
=================================================================
==45624==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000011 at pc 0x00000048a139 bp 0x7ffd11bb4930 sp 0x7ffd11bb40e0
READ of size 2 at 0x602000000011 thread T0
    #0 0x48a138 in printf_common(void*, char const*, __va_list_tag*) /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors_format.inc:547:9
    #1 0x48a9ca in vprintf /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1641:1
    #2 0x48aaa6 in printf /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1699:1
    #3 0x505052 in outputSWF_PROTECT /workspace/libming-4.7/util/outputscript.c:1691:4
    #4 0x50194c in outputBlock /workspace/libming-4.7/util/outputscript.c:2024:4
    #5 0x509175 in readMovie /workspace/libming-4.7/util/main.c:281:4
    #6 0x508197 in main /workspace/libming-4.7/util/main.c:354:2
    #7 0x7f8c263e0082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #8 0x41c44d in _start (/benchmark/bin/vanilla/swftophp-common+0x41c44d)

0x602000000011 is located 0 bytes to the right of 1-byte region [0x602000000010,0x602000000011)
allocated by thread T0 here:
    #0 0x4c156f in malloc /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3
    #1 0x509844 in dfuzz_malloc (/benchmark/bin/vanilla/swftophp-common+0x509844)
    #2 0x550a3e in readBytes /workspace/libming-4.7/util/read.c:205:17
    #3 0x54679e in parseSWF_PROTECT /workspace/libming-4.7/util/parser.c:2672:26
    #4 0x509b29 in blockParse /workspace/libming-4.7/util/blocktypes.c:149:14
    #5 0x50908c in readMovie /workspace/libming-4.7/util/main.c:269:11
    #6 0x508197 in main /workspace/libming-4.7/util/main.c:354:2
    #7 0x7f8c263e0082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16

SUMMARY: AddressSanitizer: heap-buffer-overflow /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors_format.inc:547:9 in printf_common(void*, char const*, __va_list_tag*)
Shadow bytes around the buggy address:
  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0c047fff8000: fa fa[01]fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==45624==ABORTING

```
## libming