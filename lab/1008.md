# refactoring
- windranger, Beacon에 대해서도 유사하게 refactoring후 commit
- `/workspace/libming-4.7`로 주었을때 gen_distance_orig.sh 실패
- 기존 방식 유지가 더 좋은 방법

# trigger 되지 않는 binary
## lrzip
- error log가 아닌 exit(0);
### CVE-2017-8846
- DAFL : N/A
```diff
--- a/runzip.orig	2024-09-10 10:29:45.319699629 +0000
+++ b/runzip.c	2024-09-10 10:30:05.503767537 +0000
@@ -219,7 +219,8 @@
 
 	while (len) {
 		n = MIN(len, offset);
-
+		if (unlikely(n < 1))
+			exit(0);
 		if (unlikely(read_fdhist(control, off_buf, (size_t)n) != (ssize_t)n)) {
 			free(buf);
 			fatal_return(("Failed to read %d bytes in unzip_match\n", n), -1);

--- a/stream.orig	2024-09-10 10:56:07.415526880 +0000
+++ b/stream.c	2024-09-10 10:56:37.735161557 +0000
@@ -1570,10 +1570,10 @@
 	stream_thread_struct *st;
 	uchar c_type, *s_buf;
 
-	if (s->buf)
-		free(s->buf);
 	if (s->eos)
 		goto out;
+	if (s->buf)
+		free(s->buf);
 fill_another:
 	if (unlikely(ucthread[s->uthread_no].busy))
 		failure_return(("Trying to start a busy thread, this shouldn't happen!\n"), -1);
```
### CVE-2018-11496
- DAFL : 4s
``` diff
--- a/lrzip.orig	2024-09-10 10:29:45.319699629 +0000
+++ b/lrzip.c	2024-09-10 10:30:05.503767537 +0000
@@ -803,6 +803,8 @@
 	if (!STDIN) {
 		if (unlikely(!read_magic(control, fd_in, &expected_size)))
 			return false;
+		if (unlikely(expected_size < 0))
+			exit(0);
 	}
 
 	if (!STDOUT && !TEST_ONLY) {
```

## swftophp
### CVE-2018-9132 > trigger 성공
- DAFL: 2058s
# crash가 발생하지 않는 binary
## readelf
### CVE-2018-20623 > trigger 성공
- patch file 변경
- error > fprintf(stderr, ~~)
- exit(0) 추가
``` diff
--- binutils/readelf.orig	2024-09-08 18:08:44.636561170 +0000
+++ binutils/readelf.c	2024-09-08 18:10:57.390608239 +0000
@@ -19052,7 +19052,7 @@
       /* Read the next archive header.  */
       if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
         {
-          error (_("%s: failed to seek to next archive header\n"), filedata->file_name);
+          fprintf(stderr, "%s: failed to seek to next archive header\n", arch.file_name); exit(0);
           return FALSE;
         }
       got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
@@ -19060,7 +19060,7 @@
         {
           if (got == 0)
 	    break;
-          error (_("%s: failed to read archive header\n"), filedata->file_name);
+          fprintf(stderr, "%s: failed to read archive header\n", arch.file_name); exit(0);
           ret = FALSE;
           break;
         }
@@ -19080,7 +19080,7 @@
       name = get_archive_member_name (&arch, &nested_arch);
       if (name == NULL)
 	{
-	  error (_("%s: bad archive file name\n"), filedata->file_name);
+   fprintf(stderr, "%s: bad archive file name\n", arch.file_name); exit(0);
 	  ret = FALSE;
 	  break;
 	}
@@ -19089,7 +19089,7 @@
       qualified_name = make_qualified_name (&arch, &nested_arch, name);
       if (qualified_name == NULL)
 	{
-	  error (_("%s: bad archive file name\n"), filedata->file_name);
+	  fprintf(stderr, "%s: bad archive file name\n", arch.file_name); exit(0);
 	  ret = FALSE;
 	  break;
 	}
@@ -19135,7 +19135,7 @@
 	  if (nested_arch.file == NULL)
 	    {
- 	     error (_("%s: contains corrupt thin archive: %s\n"),
-		     filedata->file_name, name);
+        fprintf(stderr, "%s: contains corrupt thin archive: %s\n", 
+		     qualified_name, name); exit(0);
 	      ret = FALSE;
 	      break;
 	    }
```
# malloc hooking
