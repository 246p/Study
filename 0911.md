# Summary
1. lrzip
- 2017-8846 : dangling pointer
- 2018-11496 : dangling pointer
- 2018-10685 : no crash
2. binutils- 2016-4487 : dangling pointer
- 2018-20623 : dangling pointer
- 2020-16592 : linked list 이동 중 free 영역 침범
# lrzip
- stream.c, runzip.c, lrzip.c
- cmdline : `$binary -t $file`
- UAF의 경우 target을 아직 설정하지 않음 (필요하다면 ASAN log를 보고 추가 가능)
## commit log
``` log
a81248e # fix CVE-2018-11496 (double free 까지)
907b66b # fix CVE-2018-11496
ed51e14 # find CVE-2018-11496
...
50cfb3b # fix CVE-2017-8846
...
d212cc1 # dealloc macro 도입
38386bd # find CVE-2018-10685 # fix는 명시되어 있지 않음, 처음부터 trigger가 되지 않음
...
9de7ccb # find CVE-2017-8846

```
## CVE-2017-8846
- DAFL, commit : 9de7ccb (0.631)
1. report : https://github.com/ckolivas/lrzip/issues/71
2. poc : https://github.com/asarubbo/poc/blob/master/00233-lrzip-UAF-read_stream
3. target : stream.c:1747
4. stack strace
``` log
==38650==ERROR: AddressSanitizer: heap-use-after-free on address 0x621000000100 at pc 0x0000004c174a bp 0x7ffd706f6a30 sp 0x7ffd706f61e0
READ of size 1 at 0x621000000100 thread T0
[Detaching after fork from child process 38829]
    #0 0x4c1749 in __asan_memcpy /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3
    #1 0x5345f6 in read_stream /workspace/lrzip-9de7ccb/BUILD/stream.c:1747:4
    #2 0x52bdc6 in read_vchars /workspace/lrzip-9de7ccb/BUILD/runzip.c:79:6
    #3 0x52b2e5 in unzip_match /workspace/lrzip-9de7ccb/BUILD/runzip.c:208:11
    #4 0x528706 in runzip_chunk /workspace/lrzip-9de7ccb/BUILD/runzip.c:329:9
    #5 0x525dd1 in runzip_fd /workspace/lrzip-9de7ccb/BUILD/runzip.c:382:7
    #6 0x50ae77 in decompress_file /workspace/lrzip-9de7ccb/BUILD/lrzip.c:826:6
    #7 0x4fe775 in main /workspace/lrzip-9de7ccb/BUILD/main.c:669:4
    #8 0x7f4a06d32082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #9 0x41d6bd in _start (/benchmark/bin/vanilla/lrzip_9-common+0x41d6bd)

0x621000000100 is located 0 bytes inside of 4096-byte region [0x621000000100,0x621000001100)
freed by thread T0 here:
    #0 0x4c24d7 in free /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:123:3
    #1 0x534c69 in fill_buffer /workspace/lrzip-9de7ccb/BUILD/stream.c:1574:3
    #2 0x5347d2 in read_stream /workspace/lrzip-9de7ccb/BUILD/stream.c:1755:8
    #3 0x52bdc6 in read_vchars /workspace/lrzip-9de7ccb/BUILD/runzip.c:79:6
    #4 0x52b2e5 in unzip_match /workspace/lrzip-9de7ccb/BUILD/runzip.c:208:11
    #5 0x528706 in runzip_chunk /workspace/lrzip-9de7ccb/BUILD/runzip.c:329:9
    #6 0x525dd1 in runzip_fd /workspace/lrzip-9de7ccb/BUILD/runzip.c:382:7
    #7 0x50ae77 in decompress_file /workspace/lrzip-9de7ccb/BUILD/lrzip.c:826:6
    #8 0x4fe775 in main /workspace/lrzip-9de7ccb/BUILD/main.c:669:4
    #9 0x7f4a06d32082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16

previously allocated by thread T1 here:
    #0 0x4c27df in malloc /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3
    #1 0x54078c in lzma_decompress_buf /workspace/lrzip-9de7ccb/BUILD/stream.c:546:20
    #2 0x54012a in ucompthread /workspace/lrzip-9de7ccb/BUILD/stream.c:1522:11
    #3 0x7f4a07117608 in start_thread /build/glibc-LcI20x/glibc-2.31/nptl/pthread_create.c:477:8

Thread T1 created by T0 here:
    #0 0x43bec6 in pthread_create /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_interceptors.cpp:214:3
    #1 0x52c8d0 in create_pthread /workspace/lrzip-9de7ccb/BUILD/stream.c:133:6
    #2 0x537083 in fill_buffer /workspace/lrzip-9de7ccb/BUILD/stream.c:1673:6
    #3 0x5347d2 in read_stream /workspace/lrzip-9de7ccb/BUILD/stream.c:1755:8
    #4 0x52bb55 in read_u8 /workspace/lrzip-9de7ccb/BUILD/runzip.c:55:6
    #5 0x52ac49 in read_header /workspace/lrzip-9de7ccb/BUILD/runzip.c:144:10
    #6 0x5284b0 in runzip_chunk /workspace/lrzip-9de7ccb/BUILD/runzip.c:314:16
    #7 0x525dd1 in runzip_fd /workspace/lrzip-9de7ccb/BUILD/runzip.c:382:7
    #8 0x50ae77 in decompress_file /workspace/lrzip-9de7ccb/BUILD/lrzip.c:826:6
    #9 0x4fe775 in main /workspace/lrzip-9de7ccb/BUILD/main.c:669:4
    #10 0x7f4a06d32082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
```
5. about bug
- deg : runzip.c:79 -> stream.c:1744 -> stream.c:1574 
```log
Thread 1 "lrzip_9-common" hit Breakpoint 6, read_vchars (control=0xf6ea60 <local_control>, ss=0x608000000020, stream=0, length=1) at runzip.c:79
79              if (unlikely(read_stream(control, ss, stream, (uchar *)&s, length) != length))
(gdb) c
Thread 1 "lrzip_9-common" hit Breakpoint 4, read_stream (control=0xf6ea60 <local_control>, ss=0x608000000020, streamno=0, p=0x7ffc0ea9f8a0 "", len=1) at stream.c:1744
1744                    n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);
(gdb) c
Thread 1 "lrzip_9-common" hit Breakpoint 5, fill_buffer (control=0xf6ea60 <local_control>, sinfo=0x608000000020, streamno=0) at stream.c:1574
1574                    free(s->buf);
(gdb) c
Thread 1 "lrzip_9-common" hit Breakpoint 4, read_stream (control=0xf6ea60 <local_control>, ss=0x608000000020, streamno=0, p=0x7ffc0ea9f8a0 "", len=1) at stream.c:1744
1744                    n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);
(gdb) s
1746                    if (n > 0) {
(gdb) s
1747                            memcpy(p, sinfo->s[streamno].buf + sinfo->s[streamno].bufp, n);
(gdb) c
Continuing.
=================================================================
==84464==ERROR: AddressSanitizer: heap-use-after-free on address 0x621000000100 at pc 0x0000004c174a bp 0x7ffc0ea9f710 sp 0x7ffc0ea9eec0
```
- source code
``` c
static inline i64 read_vchars(rzip_control *control, void *ss, int stream, int length){
    ...
    if (unlikely(read_stream(control, ss, stream, (uchar *)&s, length) != length))
    ...
}

i64 read_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)
{
	struct stream_info *sinfo = ss;
	i64 ret = 0;

	while (len) {
		i64 n;

		n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);

		if (n > 0) {
			memcpy(p, sinfo->s[streamno].buf + sinfo->s[streamno].bufp, n); /// sinfo->s[streamno].buf 접근
			sinfo->s[streamno].bufp += n;
			p += n;
			len -= n;
			ret += n;
		}

		if (len && sinfo->s[streamno].bufp == sinfo->s[streamno].buflen) {
			if (unlikely(fill_buffer(control, sinfo, streamno)))        /// sinfo->s.buf를 FREE 해줌
				return -1;
			if (sinfo->s[streamno].bufp == sinfo->s[streamno].buflen)
				break;
		}
	}

	return ret;
}
static int fill_buffer(rzip_control *control, struct stream_info *sinfo, int streamno){
    struct stream *s = &sinfo->s[streamno];
    if (s->buf) /// 항상해줌
        free(s->buf);
    if (s->eos)
		goto out; /// jump 하는경우 : UAF trigger (debug 해봄) 
...
    if (unlikely(!create_pthread(control, &threads[s->uthread_no], NULL, ucompthread, st))) {
		free(st);
		return -1;
	}
...
    out:
    s->buf = ucthread[s->unext_thread].s_buf; // s->buf에 전에 사용한 ucthread->buf pointer 할당 (이미 free 되어 있는)
}

- 하지만 어떤 상황에서 이러한 경우가 나오는지 모르겠음 
- s->eos = 1 이 되는 순간 항상 trigger 되는것인가? (poc상으론 그러함)

```
6. patch : [50cfb3b](https://github.com/ckolivas/lrzip/commit/50cfb3b), [3f37538](https://github.com/ckolivas/lrzip/commit/3f37538)
``` diff
``` diff
--- a/runzip.orig	2024-09-10 10:29:45.319699629 +0000 //50cfb3b
+++ b/runzip.c	2024-09-10 10:30:05.503767537 +0000
@@ -219,7 +219,8 @@
    
 	while (len) {
 		n = MIN(len, offset);
-
+		if (unlikely(n < 1))
+			fatal_return(("Failed fd history in unzip_match due to corrupt archive\n"), -1);
 		if (unlikely(read_fdhist(control, off_buf, (size_t)n) != (ssize_t)n)) {
 			free(buf);
 			fatal_return(("Failed to read %d bytes in unzip_match\n", n), -1);

--- a/stream.orig	2024-09-10 10:56:07.415526880 +0000 // 3f37538
+++ b/stream.c	2024-09-10 10:56:37.735161557 +0000
@@ -1570,10 +1570,10 @@
 	stream_thread_struct *st;
 	uchar c_type, *s_buf;
 
-	if (s->buf)
-		free(s->buf);
 	if (s->eos)
 		goto out;
+	if (s->buf)
+		free(s->buf);
 fill_another:
 	if (unlikely(ucthread[s->uthread_no].busy))
 		failure_return(("Trying to start a busy thread, this shouldn't happen!\n"), -1);



```

## CVE-2018-11496
- DAFL, UAFuzz
1. report : https://github.com/ckolivas/lrzip/issues/96 - ed51e1 commit
2. poc : https://github.com/ckolivas/lrzip/files/2037670/lrzip-uaf-read_stream.lrz.zip
3. target : stream.c:1756
4. stack strace

``` log
==39133==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000030 at pc 0x0000004c174a bp 0x7fff2ccfb4c0 sp 0x7fff2ccfac70
READ of size 1 at 0x602000000030 thread T0
[Detaching after fork from child process 39142]
    #0 0x4c1749 in __asan_memcpy /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3
    #1 0x536419 in read_stream /workspace/lrzip-ed51e1/BUILD/stream.c:1756:4
    #2 0x52d936 in read_vchars /workspace/lrzip-ed51e1/BUILD/runzip.c:79:6
    #3 0x52c820 in read_header /workspace/lrzip-ed51e1/BUILD/runzip.c:147:9
    #4 0x529f60 in runzip_chunk /workspace/lrzip-ed51e1/BUILD/runzip.c:316:16
    #5 0x527871 in runzip_fd /workspace/lrzip-ed51e1/BUILD/runzip.c:384:7
    #6 0x50b286 in decompress_file /workspace/lrzip-ed51e1/BUILD/lrzip.c:838:6
    #7 0x4fe8b8 in main /workspace/lrzip-ed51e1/BUILD/main.c:675:4
    #8 0x7fb70983e082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #9 0x41d6bd in _start (/benchmark/bin/vanilla/lrzip_e-common+0x41d6bd)

0x602000000030 is located 0 bytes inside of 10-byte region [0x602000000030,0x60200000003a)
freed by thread T0 here:
    #0 0x4c24d7 in free /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:123:3
    #1 0x5368ce in fill_buffer /workspace/lrzip-ed51e1/BUILD/stream.c:1573:2
    #2 0x53653b in read_stream /workspace/lrzip-ed51e1/BUILD/stream.c:1764:8
    #3 0x52d936 in read_vchars /workspace/lrzip-ed51e1/BUILD/runzip.c:79:6
    #4 0x52c820 in read_header /workspace/lrzip-ed51e1/BUILD/runzip.c:147:9
    #5 0x529f60 in runzip_chunk /workspace/lrzip-ed51e1/BUILD/runzip.c:316:16
    #6 0x527871 in runzip_fd /workspace/lrzip-ed51e1/BUILD/runzip.c:384:7
    #7 0x50b286 in decompress_file /workspace/lrzip-ed51e1/BUILD/lrzip.c:838:6
    #8 0x4fe8b8 in main /workspace/lrzip-ed51e1/BUILD/main.c:675:4
    #9 0x7fb70983e082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16

previously allocated by thread T0 here:
    #0 0x4c27df in malloc /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3
    #1 0x5384ef in fill_buffer /workspace/lrzip-ed51e1/BUILD/stream.c:1651:10
    #2 0x53653b in read_stream /workspace/lrzip-ed51e1/BUILD/stream.c:1764:8
    #3 0x52d6c5 in read_u8 /workspace/lrzip-ed51e1/BUILD/runzip.c:55:6
    #4 0x52c6f9 in read_header /workspace/lrzip-ed51e1/BUILD/runzip.c:144:10
    #5 0x529f60 in runzip_chunk /workspace/lrzip-ed51e1/BUILD/runzip.c:316:16
    #6 0x527871 in runzip_fd /workspace/lrzip-ed51e1/BUILD/runzip.c:384:7
    #7 0x50b286 in decompress_file /workspace/lrzip-ed51e1/BUILD/lrzip.c:838:6
    #8 0x4fe8b8 in main /workspace/lrzip-ed51e1/BUILD/main.c:675:4
    #9 0x7fb70983e082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16


```
5. about bug 
- 8846과 유사
- ASAN 없이 compile -> double free issue도 있음
- deg : runzip.c:79 -> stream.c:1753 -> stream.c:1573 
``` log
79              if (unlikely(read_stream(control, ss, stream, (uchar *)&s, length) != length))
(gdb) c
1753                    n = MIN(s->buflen - s->bufp, len);
(gdb) c
1573            dealloc(s->buf);
1753                    n = MIN(s->buflen - s->bufp, len);
1755                    if (n > 0) {
1756                            memcpy(p, s->buf + s->bufp, n);
(gdb) c
Continuing.
=================================================================
==95609==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000030 at pc 0x0000004c174a bp 0x7fffc5c42860 sp 0x7fffc5c42010
```
- source code
``` c
i64 read_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)
{
	struct stream_info *sinfo = ss;
	struct stream *s = &sinfo->s[streamno];
	i64 ret = 0;

	while (len) {
		i64 n;

		n = MIN(s->buflen - s->bufp, len);

		if (n > 0) {
			memcpy(p, s->buf + s->bufp, n); /// s->buf UAF
			s->bufp += n;
			p += n;
			len -= n;
			ret += n;
		}

		if (len && s->bufp == s->buflen) {
			if (unlikely(fill_buffer(control, sinfo, s, streamno))) /// FREE 
				return -1;
			if (s->bufp == s->buflen)
				break;
		}
	}

	return ret;
}

#define dealloc(ptr) do { \
	free(ptr); \
	ptr = NULL; \
} while (0)

static int fill_buffer(rzip_control *control, struct stream_info *sinfo, struct stream *s, int streamno){
    dealloc(s->buf);
    if (s->eos)
		goto out; /// jump 하는경우 : UAF trigger (debug 해봄) 
...
    if (unlikely(!create_pthread(control, &threads[s->uthread_no], NULL, ucompthread, st))) {
		free(st);
		return -1;
	}
...
    out:
    s->buf = ucthread[s->unext_thread].s_buf; // s->buf에 전에 사용한 ucthread->buf pointer 할당 (이미 free 되어 있는)
}

```
6. patch : [907b66b](https://github.com/ckolivas/lrzip/commit/907b66b8cb4ba7384abf8d82f09204b127d328bd) ,double free issue: [a81248e](https://github.com/ckolivas/lrzip/commit/a81248e)
``` diff


```

## CVE-2018-10685
- UAFuzz
- trigger 되지 않음 (lzma_decompile에서라는데 fixed commit도 명시되어 있아서 식별하기 힘듬)
- lzma_decompress_buf에서 일어나는데 apt liblzma-dev 버전의 문제일지도?
1. report : https://github.com/ckolivas/lrzip/issues/95 -38386bd
2. poc : https://github.com/ckolivas/lrzip/files/1968789/lrzip_0-631_lrzip_heap-use-after-free_.lzma_decompress_buf.lrz.zip

# binutils
## CVE-2016-4487
- DAFL, UAFuzz
- 2.26-cxxfilt
- stdin
1. report : https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70481
2. poc : DAFL
3. target : DAFL
4. stack strace
``` log
root@460c03e203e5:/benchmark# '/benchmark/bin/vanilla/cxxfilt-common' < '/benchmark/poc/binutils-2.26/20164487-a'
AddressSanitizer:DEADLYSIGNAL
=================================================================
==959==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x0000008d3dd5 bp 0x7ffd0b724cd0 sp 0x7ffd0b724c00 T0)
==959==The signal is caused by a WRITE memory access.
==959==Hint: address points to the zero page.
    #0 0x8d3dd5 in register_Btype /workspace/binutils-2.26/libiberty/./cplus-dem.c:4319:25
    #1 0x8e03ed in demangle_class /workspace/binutils-2.26/libiberty/./cplus-dem.c:2594:11
    #2 0x8ce539 in demangle_signature /workspace/binutils-2.26/libiberty/./cplus-dem.c:1490:14
    #3 0x8c8e0d in internal_cplus_demangle /workspace/binutils-2.26/libiberty/./cplus-dem.c:1203:14
    #4 0x8c5ec2 in cplus_demangle /workspace/binutils-2.26/libiberty/./cplus-dem.c:886:9
    #5 0x4f7a35 in demangle_it /workspace/binutils-2.26/binutils/cxxfilt.c:62:12
    #6 0x4f7646 in main /workspace/binutils-2.26/binutils/cxxfilt.c:275:4
    #7 0x7f6179846082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #8 0x41c56d in _start (/benchmark/bin/vanilla/cxxfilt-common+0x41c56d)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV /workspace/binutils-2.26/libiberty/./cplus-dem.c:4319:25 in register_Btype
==959==ABORTING
```
5. about bug
- gdb log
``` log
Starting program: /benchmark/bin/vanilla/cxxfilt-common < poc/binutils-2.26/20164487-a
Breakpoint 550, xmalloc_set_program_name (s=0x7fff5ee1d4b3 "/benchmark/bin/vanilla/cxxfilt-common") at ./xmalloc.c:108
108	  name = s;
Breakpoint 90, expandargv (argcp=0x7fff5ee1c040, argvp=0x7fff5ee1c050) at ./argv.c:366
366	  int i = 0;
Breakpoint 256, cplus_demangle (mangled=0x12ff2a0 <main.mbuffer> "_Q.__1", options=11) at ./cplus-dem.c:851
warning: Source file is more recent than executable.
851	  struct work_stuff work[1];
Breakpoint 158, cplus_demangle_v3 (mangled=0x12ff2a0 <main.mbuffer> "_Q.__1", options=267) at ./cp-demangle.c:6100
6100	  size_t alc;
Breakpoint 181, d_demangle (mangled=0x12ff2a0 <main.mbuffer> "_Q.__1", options=267, palc=0x7fff5ee1bd40) at ./cp-demangle.c:5940
5940	  struct d_growable_string dgs;
Breakpoint 194, d_growable_string_init (dgs=0x7fff5ee1bbe0, estimate=0) at ./cp-demangle.c:3758
3758	  dgs->buf = NULL;
Breakpoint 182, d_demangle_callback (mangled=0x12ff2a0 <main.mbuffer> "_Q.__1", options=267, callback=0x8eedb0 <d_growable_string_callback_adapter>, opaque=0x7fff5ee1bbe0) at ./cp-demangle.c:5856
5856	  struct d_info di;
Breakpoint 294, internal_cplus_demangle (work=0x7fff5ee1be20, mangled=0x12ff2a0 <main.mbuffer> "_Q.__1") at ./cplus-dem.c:1165
1165	  string decl;
Breakpoint 311, string_init (s=0x7fff5ee1bb80) at ./cplus-dem.c:4788
4788	  s->b = s->p = s->e = NULL;
Breakpoint 293, gnu_special (work=0x7fff5ee1be20, mangled=0x7fff5ee1bb60, declp=0x7fff5ee1bb80) at ./cplus-dem.c:2949
2949	  int success = 1;
Breakpoint 279, demangle_qualified (work=0x7fff5ee1be20, mangled=0x7fff5ee1bb60, result=0x7fff5ee1bb80, isfuncname=0, append=1) at ./cplus-dem.c:3282
3282	  int qualifiers = 0;
Breakpoint 299, register_Btype (work=0x7fff5ee1be20) at ./cplus-dem.c:4304
4304	  if (work -> numb >= work -> bsize)
Breakpoint 548, xmalloc (size=40) at ./xmalloc.c:145
145	  if (size == 0)
Breakpoint 311, string_init (s=0x7fff5ee1b230) at ./cplus-dem.c:4788
4788	  s->b = s->p = s->e = NULL;
Breakpoint 311, string_init (s=0x7fff5ee1b270) at ./cplus-dem.c:4788
4788	  s->b = s->p = s->e = NULL;
Breakpoint 268, delete_work_stuff (work=0x7fff5ee1be20) at ./cplus-dem.c:1352
1352	  delete_non_B_K_work_stuff (work);
Breakpoint 267, delete_non_B_K_work_stuff (work=0x7fff5ee1be20) at ./cplus-dem.c:1322
1322	  forget_types (work);
Breakpoint 291, forget_types (work=0x7fff5ee1be20) at ./cplus-dem.c:4370
4370	  while (work -> ntypes > 0)
Breakpoint 304, squangle_mop_up (work=0x7fff5ee1be20) at ./cplus-dem.c:1235
1235	  forget_B_and_K_types (work);
Breakpoint 290, forget_B_and_K_types (work=0x7fff5ee1be20) at ./cplus-dem.c:4343
4343	  while (work -> numk > 0)
Breakpoint 310, string_delete (s=0x7fff5ee1bb80) at ./cplus-dem.c:4778
4778	  if (s->b != NULL)
Breakpoint 278, demangle_prefix (work=0x7fff5ee1be20, mangled=0x7fff5ee1bb60, declp=0x7fff5ee1bb80) at ./cplus-dem.c:2740
2740	  int success = 1;
Breakpoint 295, iterate_demangle_function (work=0x7fff5ee1be20, mangled=0x7fff5ee1bb60, declp=0x7fff5ee1bb80, scan=0x12ff2a3 <main.mbuffer+3> "__1") at ./cplus-dem.c:2641
2641	  const char *mangle_init = *mangled;
Breakpoint 274, demangle_function_name (work=0x7fff5ee1be20, mangled=0x7fff5ee1bb60, declp=0x7fff5ee1bb80, scan=0x12ff2a3 <main.mbuffer+3> "__1") at ./cplus-dem.c:4590
4590	  string type;
Breakpoint 307, string_appendn (p=0x7fff5ee1bb80, s=0x12ff2a1 <main.mbuffer+1> "Q.__1", n=2) at ./cplus-dem.c:4836
4836	  if (n != 0)
Breakpoint 312, string_need (s=0x7fff5ee1bb80, n=2) at ./cplus-dem.c:4755
4755	  if (s->b == NULL)
Breakpoint 548, xmalloc (size=32) at ./xmalloc.c:145
145	  if (size == 0)
Breakpoint 312, string_need (s=0x7fff5ee1bb80, n=1) at ./cplus-dem.c:4755
4755	  if (s->b == NULL)
Breakpoint 282, demangle_signature (work=0x7fff5ee1be20, mangled=0x7fff5ee1bb60, declp=0x7fff5ee1bb80) at ./cplus-dem.c:1415
1415	  int success = 1;
Breakpoint 271, demangle_class (work=0x7fff5ee1be20, mangled=0x7fff5ee1bb60, declp=0x7fff5ee1bb80) at ./cplus-dem.c:2588
2588	  int success = 0;
Breakpoint 311, string_init (s=0x7fff5ee1b280) at ./cplus-dem.c:4788
4788	  s->b = s->p = s->e = NULL;
Breakpoint 299, register_Btype (work=0x7fff5ee1be20) at ./cplus-dem.c:4304
4304	  if (work -> numb >= work -> bsize)
Program received signal SIGSEGV, Segmentation fault.
0x00000000008d3dd5 in register_Btype (work=0x7fff5ee1be20) at ./cplus-dem.c:4319
4319	  work -> btypevec[ret] = NULL;

```
- alloc
``` c
static char *
internal_cplus_demangle (struct work_stuff *work, const char *mangled){
    ...
    success = gnu_special (work, &mangled, &decl); /// alloc
    if (!success)
    {
        delete_work_stuff (work); /// free
        string_delete (&decl);
    }
    if (!success)
	{
	  success = demangle_prefix (work, &mangled, &decl);
	}
      if (success && (*mangled != '\0'))
	{
	  success = demangle_signature (work, &mangled, &decl); ///use
	}
    ...
}
static int
gnu_special (struct work_stuff *work, const char **mangled, string *declp)
{
    ...
    success = demangle_qualified (work, mangled, declp, 0, 1);
    ...
}
static int
demangle_qualified (struct work_stuff *work, const char **mangled, string *result, int isfuncname, int append){
    ...
      int bindex = register_Btype (work); ///alloc
    ...
}

static int
register_Btype (struct work_stuff *work){
    ...
    #define XRESIZEVEC(T, P, N)	((T *) xrealloc ((void *) (P), sizeof (T) * (N)))
    work -> btypevec = XRESIZEVEC (char *, work->btypevec, work->bsize); /// allloc (size =40)
    ...
}
```
- free
```c

static char *
internal_cplus_demangle (struct work_stuff *work, const char *mangled){
    ...
    success = gnu_special (work, &mangled, &decl); /// alloc
    if (!success)
    {
        delete_work_stuff (work); /// free
        string_delete (&decl);
    }
    if (!success)
	{
	  success = demangle_prefix (work, &mangled, &decl);
	}
      if (success && (*mangled != '\0'))
	{
	  success = demangle_signature (work, &mangled, &decl); ///use
	}
    ...
}

static void
delete_work_stuff (struct work_stuff *work)
{
  delete_non_B_K_work_stuff (work);
  squangle_mop_up (work); ///free
}


static void
squangle_mop_up (struct work_stuff *work)
{
  /* clean up the B and K type mangling types. */
  forget_B_and_K_types (work);
  if (work -> btypevec != NULL)
    {
      free ((char *) work -> btypevec); /// free
      work->btypevec = NULL;
      work->bsize=0 /// fix
    }
  if (work -> ktypevec != NULL)
    {
      free ((char *) work -> ktypevec); 
      work->ktypevec = NULL;
    }
}


static void
squangle_mop_up (struct work_stuff *work)
{
    ...
    if (work -> btypevec != NULL)
    {
        free ((char *) work -> btypevec); /// free
        work->btypevec = NULL;
    }
    if (work -> ktypevec != NULL)
    {
        free ((char *) work -> ktypevec); 
        work->ktypevec = NULL;
    }
}
```
- use
``` c
static char *
internal_cplus_demangle (struct work_stuff *work, const char *mangled){
    ...
    success = gnu_special (work, &mangled, &decl); /// alloc
    if (!success)
    {
        delete_work_stuff (work); /// free
        string_delete (&decl);
    }
    if (!success)
	{
	  success = demangle_prefix (work, &mangled, &decl);
	}
      if (success && (*mangled != '\0'))
	{
	  success = demangle_signature (work, &mangled, &decl); ///use
	}
    ...
}

static int
demangle_signature (struct work_stuff *work, const char **mangled, string *declp){
    ...
    success = demangle_class (work, mangled, declp); /// use
    ...
}

static int
demangle_class (struct work_stuff *work, const char **mangled, string *declp){
    btype = register_Btype (work);
}

static int
register_Btype(struct work_stuff *work)
{
  int ret;

  if (work->numb >= work->bsize)
  {
    if (work->bsize == 0)
    {
      work->bsize = 5;
      work->btypevec = XNEWVEC(char *, work->bsize);
    }
    else
    {
      work->bsize *= 2;
      work->btypevec = XRESIZEVEC(char *, work->btypevec, work->bsize); /// allloc (size =40)
    }
  }
  ret = work->numb++;
  work->btypevec[ret] = NULL; /// use
  return (ret);
}
```
- bsize가 0으로 설정되지 않으면 work->bsize*=를 통해 realloc을 하지 않음 
- ret으로 증가시켜줬기에 work->btypevec[0]에 접근 -> UAF는 맞음, 하지만 NULLDREF
6. patch : DAFL
## CVE-2018-20623
- UAFuzz
- 2.31-readelf
- cmdline : `$binary -a $file`
1. report : https://sourceware.org/bugzilla/show_bug.cgi?id=24049, https://my.f5.com/manage/s/article/K38336243
2. poc : https://sourceware.org/bugzilla/attachment.cgi?id=11503
3. target : elfcomm.c:43
4. stack strace
``` log
==10535==ERROR: AddressSanitizer: heap-use-after-free on address 0x606000000800 at pc 0x00000048a169 bp 0x7ffd002ce180 sp 0x7ffd002cd930
READ of size 2 at 0x606000000800 thread T0
    #0 0x48a168 in printf_common(void*, char const*, __va_list_tag*) /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors_format.inc:547:9
    #1 0x48ab86 in vfprintf /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1645:1
    #2 0x5dd79f in error /workspace/binutils-2.31/binutils/elfcomm.c:43:3
    #3 0x50b0e9 in process_archive /workspace/binutils-2.31/binutils/readelf.c:19063:11
    #4 0x4fb3e3 in process_file /workspace/binutils-2.31/binutils/readelf.c:19242:13
    #5 0x4f9fd3 in main /workspace/binutils-2.31/binutils/readelf.c:19318:11
    #6 0x7f6226575082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #7 0x41c47d in _start (/benchmark/bin/vanilla/readelf-common+0x41c47d)

0x606000000800 is located 0 bytes inside of 54-byte region [0x606000000800,0x606000000836)
freed by thread T0 here:
    #0 0x4c1297 in free /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:123:3
    #1 0x50bae2 in process_archive /workspace/binutils-2.31/binutils/readelf.c:19178:7
    #2 0x4fb3e3 in process_file /workspace/binutils-2.31/binutils/readelf.c:19242:13
    #3 0x4f9fd3 in main /workspace/binutils-2.31/binutils/readelf.c:19318:11
    #4 0x7f6226575082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16

previously allocated by thread T0 here:
    #0 0x4c159f in malloc /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3
    #1 0x5e3f66 in make_qualified_name /workspace/binutils-2.31/binutils/elfcomm.c:906:19
    #2 0x50b309 in process_archive /workspace/binutils-2.31/binutils/readelf.c:19089:24
    #3 0x4fb3e3 in process_file /workspace/binutils-2.31/binutils/readelf.c:19242:13
    #4 0x4f9fd3 in main /workspace/binutils-2.31/binutils/readelf.c:19318:11
    #5 0x7f6226575082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
```
5. about bug 
- `r -a /benchmark/poc/binutils-2.31/201820623 > /dev/null`
- 함수 시작 `b readelf.c:18931` 
- while 시작 `b readelf.c:19053`
- gdb log
``` log
1: filedata->file_name = 0x7ffc0ee3c465 "poc/binutils-2.31/201820623
19046     while (1)
19053         if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
19058         got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
19059         if (got != sizeof arch.arhdr)
19067         if (memcmp (arch.arhdr.ar_fmag, ARFMAG, 2) != 0)
19074         arch.next_arhdr_offset += sizeof arch.arhdr;
19076         archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);
19077         if (archive_file_size & 01)
19080         name = get_archive_member_name (&arch, &nested_arch);
19081         if (name == NULL)
19087         namelen = strlen (name);
19089         qualified_name = make_qualified_name (&arch, &nested_arch, name);
19090         if (qualified_name == NULL)
19097         if (is_thin_archive && arch.nested_member_origin == 0)
19128         else if (is_thin_archive)
19163             archive_file_offset = arch.next_arhdr_offset;
19164             arch.next_arhdr_offset += archive_file_size;
19166             filedata->file_name = qualified_name;
19167             if (! process_object (filedata))
1: filedata->file_name = 0x604000001490 "poc/binutils-2.31/201820623(", 'a' <repeats 16 times>, ")
19168               ret = FALSE;
19171         if (filedata->dump_sects != NULL)
19178         free (qualified_name);
19179       }
19046     while (1)
1: filedata->file_name = 0x604000001490 "\001
19053         if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
19058         got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
19059         if (got != sizeof arch.arhdr)
19067         if (memcmp (arch.arhdr.ar_fmag, ARFMAG, 2) != 0)
19074         arch.next_arhdr_offset += sizeof arch.arhdr;
19076         archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);
19077         if (archive_file_size & 01)
19080         name = get_archive_member_name (&arch, &nested_arch);
19081         if (name == NULL)
19087         namelen = strlen (name);
19089         qualified_name = make_qualified_name (&arch, &nested_arch, name);
19090         if (qualified_name == NULL)
19097         if (is_thin_archive && arch.nested_member_origin == 0)
19128         else if (is_thin_archive)
19163             archive_file_offset = arch.next_arhdr_offset;
19164             arch.next_arhdr_offset += archive_file_size;
19166             filedata->file_name = qualified_name;
19167             if (! process_object (filedata))
1: filedata->file_name = 0x6040000014d0 "poc/binutils-2.31/201820623(gethnamaddr.o)
19171         if (filedata->dump_sects != NULL)
19178         free (qualified_name);
19179       }
1: filedata->file_name = 0x6040000014d0 "\001
19046     while (1)
19053         if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
19058         got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
19059         if (got != sizeof arch.arhdr)
19061             if (got == 0)
19063             error (_("%s: failed to read archive header\n"), arch.file_name);
1: filedata->file_name = 0x6040000014d0 "\001"
```
- source code
``` c
static bfd_boolean
process_archive (Filedata * filedata, bfd_boolean is_thin_archive){
    struct archive_info arch;
    ...
    while (1)
    {
        char * name;
        size_t namelen;
        char * qualified_name;
        if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
        {
          error (_("%s: failed to seek to next archive header\n"), filedata->file_name);
          return FALSE;
        }
        got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
        if (got != sizeof arch.arhdr)
        {
            if (got == 0)
	    break;
            /// short count가 발생할 경우
            error (_("%s: failed to read archive header\n"), filedata->file_name); /// Use-After-Free
            ret = FALSE;
            break;
        }

        qualified_name = make_qualified_name (&arch, &nested_arch, name);

        if (is_thin_archive && arch.nested_member_origin == 0)...
        else if (is_thin_archive)...
        else
        {
            archive_file_offset = arch.next_arhdr_offset;
            arch.next_arhdr_offset += archive_file_size;

	        filedata->file_name = qualified_name; /// pointer 지정
            if (! process_object (filedata))
	            ret = FALSE;
        }
        if (filedata->dump_sects != NULL)...
        
        free (qualified_name); /// free
    }
    ...
}


```
6. patch : [28e817cc440](https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=28e817cc440bce73691c03e01860089a0954a837)
- ASAN_OPTIONS=detect_leaks=0 필요
``` diff
--- binutils/readelf.orig	2024-09-08 18:08:44.636561170 +0000
+++ binutils/readelf.c	2024-09-08 18:10:57.390608239 +0000
@@ -19052,7 +19052,7 @@
       /* Read the next archive header.  */
       if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
         {
-          error (_("%s: failed to seek to next archive header\n"), filedata->file_name);
+          error (_("%s: failed to seek to next archive header\n"), arch.file_name);
           return FALSE;
         }
       got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
@@ -19060,7 +19060,7 @@
         {
           if (got == 0)
 	    break;
-          error (_("%s: failed to read archive header\n"), filedata->file_name);
+          error (_("%s: failed to read archive header\n"), arch.file_name);
           ret = FALSE;
           break;
         }
@@ -19080,7 +19080,7 @@
       name = get_archive_member_name (&arch, &nested_arch);
       if (name == NULL)
 	{
-	  error (_("%s: bad archive file name\n"), filedata->file_name);
+	  error (_("%s: bad archive file name\n"), arch.file_name);
 	  ret = FALSE;
 	  break;
 	}
@@ -19089,7 +19089,7 @@
       qualified_name = make_qualified_name (&arch, &nested_arch, name);
       if (qualified_name == NULL)
 	{
-	  error (_("%s: bad archive file name\n"), filedata->file_name);
+	  error (_("%s: bad archive file name\n"), arch.file_name);
 	  ret = FALSE;
 	  break;
 	}
@@ -19135,7 +19135,7 @@
 	  if (nested_arch.file == NULL)
 	    {
 	      error (_("%s: contains corrupt thin archive: %s\n"),
-		     filedata->file_name, name);
+		     qualified_name, name);
 	      ret = FALSE;
 	      break;
 	    }

```
## CVE-2020-16592
- googling
- 2.34-nm-new
- cmdline : `$binary -C $file`
1. report : https://sourceware.org/bugzilla/show_bug.cgi?id=25823
2. poc : https://sourceware.org/bugzilla/attachment.cgi?id=12458
3. target :
4. stack strace
``` log
==11069==ERROR: AddressSanitizer: heap-use-after-free on address 0x7f0bbf77580e at pc 0x00000049b632 bp 0x7ffe4042aed0 sp 0x7ffe4042a680
READ of size 19 at 0x7f0bbf77580e thread T0
    #0 0x49b631 in __interceptor_strcmp.part.0 /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:448:3
    #1 0x52f43c in bfd_hash_lookup /workspace/binutils-2.34/bfd/hash.c:475:7
    #2 0x53dcfc in bfd_get_section_by_name /workspace/binutils-2.34/bfd/section.c:884:8
    #3 0x76d21a in _bfd_pei_swap_sym_in /workspace/binutils-2.34/bfd/peigen.c:170:10
    #4 0x7c97c9 in coff_get_normalized_symtab /workspace/binutils-2.34/bfd/coffgen.c:1849:7
    #5 0x761d69 in coff_slurp_symbol_table /workspace/binutils-2.34/bfd/./coffcode.h:4465:25
    #6 0x7be031 in coff_get_symtab_upper_bound /workspace/binutils-2.34/bfd/coffgen.c:426:8
    #7 0x541962 in _bfd_generic_read_minisymbols /workspace/binutils-2.34/bfd/syms.c:813:15
    #8 0x4faa26 in display_rel_file /workspace/binutils-2.34/binutils/nm.c:1112:14
    #9 0x4f7e97 in display_file /workspace/binutils-2.34/binutils/nm.c:1379:7
    #10 0x4f7720 in main /workspace/binutils-2.34/binutils/nm.c:1860:12
    #11 0x7f0bc2376082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #12 0x41c56d in _start (/benchmark/bin/vanilla/nmnew-common+0x41c56d)

0x7f0bbf77580e is located 14 bytes inside of 235653-byte region [0x7f0bbf775800,0x7f0bbf7af085)
freed by thread T0 here:
    #0 0x4c1387 in free /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:123:3
    #1 0x7bd053 in _bfd_coff_free_symbols /workspace/binutils-2.34/bfd/coffgen.c:1789:7
    #2 0x7bad98 in coff_real_object_p /workspace/binutils-2.34/bfd/coffgen.c:307:3
    #3 0x74d950 in pe_bfd_object_p /workspace/binutils-2.34/bfd/./peicode.h:1511:12
    #4 0x52c5a7 in bfd_check_format_matches /workspace/binutils-2.34/bfd/format.c:328:14
    #5 0x4f7e39 in display_file /workspace/binutils-2.34/binutils/nm.c:1375:12
    #6 0x4f7720 in main /workspace/binutils-2.34/binutils/nm.c:1860:12
    #7 0x7f0bc2376082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16

previously allocated by thread T0 here:
    #0 0x4c168f in malloc /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3
    #1 0x53281c in bfd_malloc /workspace/binutils-2.34/bfd/libbfd.c:275:9
    #2 0x7bec9a in _bfd_coff_read_string_table /workspace/binutils-2.34/bfd/coffgen.c:1747:22
    #3 0x7be4a4 in _bfd_coff_internal_syment_name /workspace/binutils-2.34/bfd/coffgen.c:479:14
    #4 0x76d1af in _bfd_pei_swap_sym_in /workspace/binutils-2.34/bfd/peigen.c:161:11
    #5 0x76b68c in handle_COMDAT /workspace/binutils-2.34/bfd/./coffcode.h:916:7
    #6 0x76949c in styp_to_sec_flags /workspace/binutils-2.34/bfd/./coffcode.h:1297:16
    #7 0x7bc09c in make_a_section_from_file /workspace/binutils-2.34/bfd/coffgen.c:130:9
    #8 0x7bab9e in coff_real_object_p /workspace/binutils-2.34/bfd/coffgen.c:300:10
    #9 0x74d950 in pe_bfd_object_p /workspace/binutils-2.34/bfd/./peicode.h:1511:12
    #10 0x52c5a7 in bfd_check_format_matches /workspace/binutils-2.34/bfd/format.c:328:14
    #11 0x4f7e39 in display_file /workspace/binutils-2.34/binutils/nm.c:1375:12
    #12 0x4f7720 in main /workspace/binutils-2.34/binutils/nm.c:1860:12
    #13 0x7f0bc2376082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
```
5. about bug 


- alloc/free
``` c
static bfd_boolean
display_file (char *filename){
    bfd *file;
    ...
    else if (bfd_check_format_matches (file, bfd_object, &matching)) ///alloc, free
    /// file->특정 offset대한 free 가 되어있음
    {
      set_print_width (file);
      format->print_object_filename (filename);
      display_rel_file (file, NULL); /// use
    }
}


bfd_boolean
bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching){
    ...
    #define BFD_SEND_FMT(bfd, message, arglist) \
    (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
    
    temp = BFD_SEND_FMT (abfd, _bfd_check_format, (abfd)); /// alloc, free
}

static const bfd_target *
pe_bfd_object_p (bfd * abfd){
    ...
      result = coff_real_object_p (abfd, internal_f.f_nscns, &internal_f,
			       (opt_hdr_size != 0
				? &internal_a
				: (struct internal_aouthdr *) NULL)); ///alloc, free
    ...
}


const bfd_target *
coff_real_object_p (bfd *abfd, unsigned nscns, struct internal_filehdr *internal_f, struct internal_aouthdr *internal_a){
    ...
    if (nscns != 0)
        {
        unsigned int i;
        for (i = 0; i < nscns; i++)
        {
        struct internal_scnhdr tmp;
        bfd_coff_swap_scnhdr_in (abfd,
                    (void *) (external_sections + i * scnhsz),
                    (void *) & tmp);
        if (! make_a_section_from_file (abfd, &tmp, i + 1)) /// alloc
            goto fail;
        }
        }
    obj_coff_keep_syms (abfd) = FALSE;
    obj_coff_keep_strings (abfd) = FALSE;

    #define coff_data(bfd)		          ((bfd)->tdata.coff_obj_data)
    #define obj_coff_strings(bfd)	      (coff_data (bfd)->strings)
    _bfd_coff_free_symbols (abfd); > free (obj_coff_strings (abfd)) > /// FREE

    return abfd->xvec;
    ...
    }

static bfd_boolean
make_a_section_from_file (bfd *abfd,
    struct internal_scnhdr *hdr,
    unsigned int target_index){
        ...
    if (!((bfd_coff_backend_data *) (abfd)->xvec->backend_data)->_bfd_styp_to_sec_flags_hook
    (abfd, hdr, name, return_section, &flags)) /// alloc

}

static bfd_boolean
styp_to_sec_flags (bfd *abfd, void * hdr, const char *name, asection *section, flagword *flags_ptr){
    ...
    sec_flags = handle_COMDAT (abfd, sec_flags, hdr, name, section); ///alloc
    ...
}

static flagword
handle_COMDAT (bfd * abfd, flagword sec_flags, void * hdr, const char *name, asection *section){
    ...
    bfd_coff_swap_sym_in (abfd, esym, & isym); ///alloc
    ...
}

void
_bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1){
    ...
    name = _bfd_coff_internal_syment_name (abfd, in, namebuf); /// alloc
	  if (name == NULL)
	    {
	      _bfd_error_handler (_("%pB: unable to find name for empty section"),
				  abfd);
	      bfd_set_error (bfd_error_invalid_target);
	      return;
	    }

	  sec = bfd_get_section_by_name (abfd, name);
}

const char *
_bfd_coff_internal_syment_name (bfd *abfd, const struct internal_syment *sym, char *buf){
    ...
    strings = _bfd_coff_read_string_table (abfd); ///alloc
    ...
}

const char *
_bfd_coff_read_string_table (bfd *abfd){
    ...
    strings = (char *) bfd_malloc (strsize + 1); /// alloc
    ...
    obj_coff_strings (abfd) = strings;
    ...
}
```

- use
``` c
static bfd_boolean
display_file (char *filename){
    bfd *file;
    ...
    else if (bfd_check_format_matches (file, bfd_object, &matching)) ///alloc, free
    /// file->특정 offset대한 free 가 되어있음
    {
      set_print_width (file);
      format->print_object_filename (filename);
      display_rel_file (file, NULL); /// use
    }
}


static void
display_rel_file (bfd *abfd, bfd *archive_bfd){
    ...
    symcount = (*((abfd)->xvec->_read_minisymbols)) (abfd, dynamic, &minisyms, &size);
    ...
}

long
_bfd_generic_read_minisymbols (bfd *abfd, bfd_boolean dynamic, void **minisymsp, unsigned int *sizep){
    ...
    storage = (*((abfd)->xvec->_bfd_get_symtab_upper_bound)) (abfd);
    ...
}

long
coff_get_symtab_upper_bound (bfd *abfd){
    ...
    if (!(*((bfd_coff_backend_data *) (abfd)->xvec->backend_data)->_bfd_coff_slurp_symbol_table) (abfd)) 
    ...
}

combined_entry_type *
coff_get_normalized_symtab (bfd *abfd){
    (*((bfd_coff_backend_data *) (abfd)->xvec->backend_data)->_bfd_coff_swap_sym_in) (abfd, (void *) raw_src, (void *) &internal_ptr->u.syment);
}

void
_bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1){
    sec = bfd_get_section_by_name (abfd, name);
}

asection *
bfd_get_section_by_name (bfd *abfd, const char *name){
    sh = ((struct section_hash_entry *)bfd_hash_lookup(&abfd->section_htab, name, FALSE, FALSE);
}


struct bfd_hash_entry *
bfd_hash_lookup (struct bfd_hash_table *table, const char *string, bfd_boolean create, bfd_boolean copy){
    unsigned long hash;
    struct bfd_hash_entry *hashp;
    unsigned int len;
    unsigned int _index;

    hash = bfd_hash_hash (string, &len);
    _index = hash % table->size;
    for (hashp = table->table[_index]; hashp != NULL; hashp = hashp->next)
        if (hashp->hash == hash && strcmp (hashp->string, string) == 0) // strcmp hashp->string 에서 use
            return hashp;
}
```
- struct
``` c
struct bfd
{
    ...
    struct bfd_hash_table section_htab; /// USE
    ...
    union {
    ...
    struct coff_tdata *coff_obj_data; /// ->strings에 data
    ...
    } tdata;
    ...
};

struct bfd_hash_table
{
    struct bfd_hash_entry **table;
...
};

typedef struct coff_tdata
{
    ...
    char *strings;
    ...
} coff_data_type;
```

- 결론 BOF식인것 같다. (확실하지 않음)

6. patch : https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=7ecb51549ab1ec22aba5aaf34b70323cf0b8509a
- 적용이 안됨

# TODO
- lrzip build (afl)
- triage 실행시 ASAN option 적용
- fuzzer script에 `ASAN_OPTIONS=abort_on_error=1:symbolize=0:detect_leaks=0` 추가
- 실제 binary 이름과 output binary이름이 다른 경우 build : lrzip (version), nm-new (triage parsing error)