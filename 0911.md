# TODO
- UAF 검증하기, bug에 대한 분석
- `git clone https://github.com/ckolivas/lrzip.git /workspace/lrzip_orig; cd /workspace/lrzip_orig; git reset --hard 9de7ccb; code stream.c; code runzip.c`
- lrzip: 2017-8846 (DAFL) & 2018-11496 (DAFL, UAFuzz), CVE-2018-10685 (UAFuzz)
- binutils: CVE-2016-4487 (아닐 가능성 높음), CVE-2018-20623 (UAF), CVE-2020-16592 (Googling)
- ASAN_OPTIONS=detect_leaks=0,allocator_may_return_null=1
# lrzip
- stream.c, runzip.c
- cmdline : `$binary -t $file`
- UAF의 경우 target을 아직 설정하지 않음 (필요하다면 ASAN log를 보고 추가 가능)
# commit log
``` log
a81248e # fix CVE-2018-11496 (double free 까지)
907b66b # fix CVE-2018-11496
ed51e14 # find CVE-2018-11496
...
50cfb3b # fix CVE-2017-8846
...
d212cc1 # dealloc macro 도입
38386bd # find CVE-2018-10685 # fix는 명시되어 있지 않음, 처음부터 trigger가 되지 않음
...
9de7ccb # find CVE-2017-8846

```
## CVE-2017-8846
- DAFL, commit : 9de7ccb (0.631)
1. report : https://github.com/ckolivas/lrzip/issues/71
2. poc : https://github.com/asarubbo/poc/blob/master/00233-lrzip-UAF-read_stream
3. target :
4. stack strace
``` log
==38650==ERROR: AddressSanitizer: heap-use-after-free on address 0x621000000100 at pc 0x0000004c174a bp 0x7ffd706f6a30 sp 0x7ffd706f61e0
READ of size 1 at 0x621000000100 thread T0
[Detaching after fork from child process 38829]
    #0 0x4c1749 in __asan_memcpy /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3
    #1 0x5345f6 in read_stream /workspace/lrzip-9de7ccb/BUILD/stream.c:1747:4
    #2 0x52bdc6 in read_vchars /workspace/lrzip-9de7ccb/BUILD/runzip.c:79:6
    #3 0x52b2e5 in unzip_match /workspace/lrzip-9de7ccb/BUILD/runzip.c:208:11
    #4 0x528706 in runzip_chunk /workspace/lrzip-9de7ccb/BUILD/runzip.c:329:9
    #5 0x525dd1 in runzip_fd /workspace/lrzip-9de7ccb/BUILD/runzip.c:382:7
    #6 0x50ae77 in decompress_file /workspace/lrzip-9de7ccb/BUILD/lrzip.c:826:6
    #7 0x4fe775 in main /workspace/lrzip-9de7ccb/BUILD/main.c:669:4
    #8 0x7f4a06d32082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #9 0x41d6bd in _start (/benchmark/bin/vanilla/lrzip_9-common+0x41d6bd)

0x621000000100 is located 0 bytes inside of 4096-byte region [0x621000000100,0x621000001100)
freed by thread T0 here:
    #0 0x4c24d7 in free /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:123:3
    #1 0x534c69 in fill_buffer /workspace/lrzip-9de7ccb/BUILD/stream.c:1574:3
    #2 0x5347d2 in read_stream /workspace/lrzip-9de7ccb/BUILD/stream.c:1755:8
    #3 0x52bdc6 in read_vchars /workspace/lrzip-9de7ccb/BUILD/runzip.c:79:6
    #4 0x52b2e5 in unzip_match /workspace/lrzip-9de7ccb/BUILD/runzip.c:208:11
    #5 0x528706 in runzip_chunk /workspace/lrzip-9de7ccb/BUILD/runzip.c:329:9
    #6 0x525dd1 in runzip_fd /workspace/lrzip-9de7ccb/BUILD/runzip.c:382:7
    #7 0x50ae77 in decompress_file /workspace/lrzip-9de7ccb/BUILD/lrzip.c:826:6
    #8 0x4fe775 in main /workspace/lrzip-9de7ccb/BUILD/main.c:669:4
    #9 0x7f4a06d32082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16

previously allocated by thread T1 here:
    #0 0x4c27df in malloc /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3
    #1 0x54078c in lzma_decompress_buf /workspace/lrzip-9de7ccb/BUILD/stream.c:546:20
    #2 0x54012a in ucompthread /workspace/lrzip-9de7ccb/BUILD/stream.c:1522:11
    #3 0x7f4a07117608 in start_thread /build/glibc-LcI20x/glibc-2.31/nptl/pthread_create.c:477:8

Thread T1 created by T0 here:
    #0 0x43bec6 in pthread_create /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_interceptors.cpp:214:3
    #1 0x52c8d0 in create_pthread /workspace/lrzip-9de7ccb/BUILD/stream.c:133:6
    #2 0x537083 in fill_buffer /workspace/lrzip-9de7ccb/BUILD/stream.c:1673:6
    #3 0x5347d2 in read_stream /workspace/lrzip-9de7ccb/BUILD/stream.c:1755:8
    #4 0x52bb55 in read_u8 /workspace/lrzip-9de7ccb/BUILD/runzip.c:55:6
    #5 0x52ac49 in read_header /workspace/lrzip-9de7ccb/BUILD/runzip.c:144:10
    #6 0x5284b0 in runzip_chunk /workspace/lrzip-9de7ccb/BUILD/runzip.c:314:16
    #7 0x525dd1 in runzip_fd /workspace/lrzip-9de7ccb/BUILD/runzip.c:382:7
    #8 0x50ae77 in decompress_file /workspace/lrzip-9de7ccb/BUILD/lrzip.c:826:6
    #9 0x4fe775 in main /workspace/lrzip-9de7ccb/BUILD/main.c:669:4
    #10 0x7f4a06d32082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
```
5. about bug
- deg : runzip.c:79 -> stream.c:1744 -> stream.c:1574 
```log
Thread 1 "lrzip_9-common" hit Breakpoint 6, read_vchars (control=0xf6ea60 <local_control>, ss=0x608000000020, stream=0, length=1) at runzip.c:79
79              if (unlikely(read_stream(control, ss, stream, (uchar *)&s, length) != length))
(gdb) c
Thread 1 "lrzip_9-common" hit Breakpoint 4, read_stream (control=0xf6ea60 <local_control>, ss=0x608000000020, streamno=0, p=0x7ffc0ea9f8a0 "", len=1) at stream.c:1744
1744                    n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);
(gdb) c
Thread 1 "lrzip_9-common" hit Breakpoint 5, fill_buffer (control=0xf6ea60 <local_control>, sinfo=0x608000000020, streamno=0) at stream.c:1574
1574                    free(s->buf);
(gdb) c
Thread 1 "lrzip_9-common" hit Breakpoint 4, read_stream (control=0xf6ea60 <local_control>, ss=0x608000000020, streamno=0, p=0x7ffc0ea9f8a0 "", len=1) at stream.c:1744
1744                    n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);
(gdb) s
1746                    if (n > 0) {
(gdb) s
1747                            memcpy(p, sinfo->s[streamno].buf + sinfo->s[streamno].bufp, n);
(gdb) c
Continuing.
=================================================================
==84464==ERROR: AddressSanitizer: heap-use-after-free on address 0x621000000100 at pc 0x0000004c174a bp 0x7ffc0ea9f710 sp 0x7ffc0ea9eec0
```
- source code
``` c
static inline i64 read_vchars(rzip_control *control, void *ss, int stream, int length){
    ...
    if (unlikely(read_stream(control, ss, stream, (uchar *)&s, length) != length))
    ...
}

i64 read_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)
{
	struct stream_info *sinfo = ss;
	i64 ret = 0;

	while (len) {
		i64 n;

		n = MIN(sinfo->s[streamno].buflen - sinfo->s[streamno].bufp, len);

		if (n > 0) {
			memcpy(p, sinfo->s[streamno].buf + sinfo->s[streamno].bufp, n); /// sinfo->s[streamno].buf 접근
			sinfo->s[streamno].bufp += n;
			p += n;
			len -= n;
			ret += n;
		}

		if (len && sinfo->s[streamno].bufp == sinfo->s[streamno].buflen) {
			if (unlikely(fill_buffer(control, sinfo, streamno)))        /// sinfo->s.buf를 FREE 해줌
				return -1;
			if (sinfo->s[streamno].bufp == sinfo->s[streamno].buflen)
				break;
		}
	}

	return ret;
}
static int fill_buffer(rzip_control *control, struct stream_info *sinfo, int streamno){
    struct stream *s = &sinfo->s[streamno];
    if (s->buf) /// 항상해줌
        free(s->buf);
    if (s->eos)
		goto out; /// jump 하는경우 : UAF trigger (debug 해봄) 
...
    if (unlikely(!create_pthread(control, &threads[s->uthread_no], NULL, ucompthread, st))) {
		free(st);
		return -1;
	}
...
    out:
    s->buf = ucthread[s->unext_thread].s_buf; // s->buf에 전에 사용한 ucthread->buf pointer 할당 (이미 free 되어 있는)
}

- 하지만 어떤 상황에서 이러한 경우가 나오는지 모르겠음 
- s->eos = 1 이 되는 순간 항상 trigger 되는것인가? (poc상으론 그러함)

```
6. patch : 50cfb3b
``` diff


```

## CVE-2018-11496
- DAFL, UAFuzz
1. report : https://github.com/ckolivas/lrzip/issues/96 - ed51e1 commit
2. poc : https://github.com/ckolivas/lrzip/files/2037670/lrzip-uaf-read_stream.lrz.zip
3. target :
4. stack strace

``` log
==39133==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000030 at pc 0x0000004c174a bp 0x7fff2ccfb4c0 sp 0x7fff2ccfac70
READ of size 1 at 0x602000000030 thread T0
[Detaching after fork from child process 39142]
    #0 0x4c1749 in __asan_memcpy /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3
    #1 0x536419 in read_stream /workspace/lrzip-ed51e1/BUILD/stream.c:1756:4
    #2 0x52d936 in read_vchars /workspace/lrzip-ed51e1/BUILD/runzip.c:79:6
    #3 0x52c820 in read_header /workspace/lrzip-ed51e1/BUILD/runzip.c:147:9
    #4 0x529f60 in runzip_chunk /workspace/lrzip-ed51e1/BUILD/runzip.c:316:16
    #5 0x527871 in runzip_fd /workspace/lrzip-ed51e1/BUILD/runzip.c:384:7
    #6 0x50b286 in decompress_file /workspace/lrzip-ed51e1/BUILD/lrzip.c:838:6
    #7 0x4fe8b8 in main /workspace/lrzip-ed51e1/BUILD/main.c:675:4
    #8 0x7fb70983e082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16
    #9 0x41d6bd in _start (/benchmark/bin/vanilla/lrzip_e-common+0x41d6bd)

0x602000000030 is located 0 bytes inside of 10-byte region [0x602000000030,0x60200000003a)
freed by thread T0 here:
    #0 0x4c24d7 in free /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:123:3
    #1 0x5368ce in fill_buffer /workspace/lrzip-ed51e1/BUILD/stream.c:1573:2
    #2 0x53653b in read_stream /workspace/lrzip-ed51e1/BUILD/stream.c:1764:8
    #3 0x52d936 in read_vchars /workspace/lrzip-ed51e1/BUILD/runzip.c:79:6
    #4 0x52c820 in read_header /workspace/lrzip-ed51e1/BUILD/runzip.c:147:9
    #5 0x529f60 in runzip_chunk /workspace/lrzip-ed51e1/BUILD/runzip.c:316:16
    #6 0x527871 in runzip_fd /workspace/lrzip-ed51e1/BUILD/runzip.c:384:7
    #7 0x50b286 in decompress_file /workspace/lrzip-ed51e1/BUILD/lrzip.c:838:6
    #8 0x4fe8b8 in main /workspace/lrzip-ed51e1/BUILD/main.c:675:4
    #9 0x7fb70983e082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16

previously allocated by thread T0 here:
    #0 0x4c27df in malloc /fuzzer/AFLGo/instrument/llvm_tools/compiler-rt/lib/asan/asan_malloc_linux.cpp:145:3
    #1 0x5384ef in fill_buffer /workspace/lrzip-ed51e1/BUILD/stream.c:1651:10
    #2 0x53653b in read_stream /workspace/lrzip-ed51e1/BUILD/stream.c:1764:8
    #3 0x52d6c5 in read_u8 /workspace/lrzip-ed51e1/BUILD/runzip.c:55:6
    #4 0x52c6f9 in read_header /workspace/lrzip-ed51e1/BUILD/runzip.c:144:10
    #5 0x529f60 in runzip_chunk /workspace/lrzip-ed51e1/BUILD/runzip.c:316:16
    #6 0x527871 in runzip_fd /workspace/lrzip-ed51e1/BUILD/runzip.c:384:7
    #7 0x50b286 in decompress_file /workspace/lrzip-ed51e1/BUILD/lrzip.c:838:6
    #8 0x4fe8b8 in main /workspace/lrzip-ed51e1/BUILD/main.c:675:4
    #9 0x7fb70983e082 in __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:308:16


```
5. about bug 
- 8846과 유사
- ASAN 없이 compile -> double free issue도 있음
- deg : runzip.c:79 -> stream.c:1753 -> stream.c:1573 
``` log
Thread 1 "lrzip_e-common" hit Breakpoint 1, read_vchars (control=0xf70c40 <local_control>, ss=0x608000000020, stream=0, length=2) at runzip.c:79
79              if (unlikely(read_stream(control, ss, stream, (uchar *)&s, length) != length))
(gdb) c
Continuing.

Thread 1 "lrzip_e-common" hit Breakpoint 3, read_stream (control=0xf70c40 <local_control>, ss=0x608000000020, streamno=0, p=0x7fffc5c429a0 "", len=2) at stream.c:1753
1753                    n = MIN(s->buflen - s->bufp, len);
(gdb) c
Continuing.

Thread 1 "lrzip_e-common" hit Breakpoint 2, fill_buffer (control=0xf70c40 <local_control>, sinfo=0x608000000020, s=0x60e000000040, streamno=0) at stream.c:1573
1573            dealloc(s->buf);
(gdb) c
Continuing.

Thread 1 "lrzip_e-common" hit Breakpoint 3, read_stream (control=0xf70c40 <local_control>, ss=0x608000000020, streamno=0, p=0x7fffc5c429a1 "", len=1) at stream.c:1753
1753                    n = MIN(s->buflen - s->bufp, len);
(gdb) s
1755                    if (n > 0) {
(gdb) s
1756                            memcpy(p, s->buf + s->bufp, n);
(gdb) c
Continuing.
=================================================================
==95609==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000030 at pc 0x0000004c174a bp 0x7fffc5c42860 sp 0x7fffc5c42010
```
- source code
``` c
i64 read_stream(rzip_control *control, void *ss, int streamno, uchar *p, i64 len)
{
	struct stream_info *sinfo = ss;
	struct stream *s = &sinfo->s[streamno];
	i64 ret = 0;

	while (len) {
		i64 n;

		n = MIN(s->buflen - s->bufp, len);

		if (n > 0) {
			memcpy(p, s->buf + s->bufp, n); /// s->buf UAF
			s->bufp += n;
			p += n;
			len -= n;
			ret += n;
		}

		if (len && s->bufp == s->buflen) {
			if (unlikely(fill_buffer(control, sinfo, s, streamno))) /// FREE 
				return -1;
			if (s->bufp == s->buflen)
				break;
		}
	}

	return ret;
}

#define dealloc(ptr) do { \
	free(ptr); \
	ptr = NULL; \
} while (0)

static int fill_buffer(rzip_control *control, struct stream_info *sinfo, struct stream *s, int streamno){
    dealloc(s->buf);
    if (s->eos)
		goto out; /// jump 하는경우 : UAF trigger (debug 해봄) 
...
    if (unlikely(!create_pthread(control, &threads[s->uthread_no], NULL, ucompthread, st))) {
		free(st);
		return -1;
	}
...
    out:
    s->buf = ucthread[s->unext_thread].s_buf; // s->buf에 전에 사용한 ucthread->buf pointer 할당 (이미 free 되어 있는)
}

```
6. patch : 907b66b (double free issue 까지 해결하려면 a81248e)
``` diff


```

## CVE-2018-10685
- UAFuzz
- trigger 되지 않음 (lzma_decompile에서라는데 fixed commit도 명시되어 있아서 식별하기 힘듬)
1. report : https://github.com/ckolivas/lrzip/issues/95 -38386bd
2. poc : https://github.com/ckolivas/lrzip/files/1968789/lrzip_0-631_lrzip_heap-use-after-free_.lzma_decompress_buf.lrz.zip
3. target :
4. stack strace
``` log
```
5. about bug 
6. patch : 
``` diff
```


# binutils
## CVE-2016-4487 (아닐가능성 높음)
- DAFL, UAFuzz
- 
1. report : https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70481
2. poc
3. target :
4. stack strace
``` log



```
5. about bug 
 
6. patch : 
``` diff


```
## CVE-2018-20623
- UAFuzz
1. report : https://sourceware.org/bugzilla/show_bug.cgi?id=24049, https://my.f5.com/manage/s/article/K38336243
2. poc : https://sourceware.org/bugzilla/attachment.cgi?id=11503
3. target :
4. stack strace
``` log



```
5. about bug 
 
6. patch : 
``` diff


```
## CVE-2020-16592
- googling
1. report : https://sourceware.org/bugzilla/show_bug.cgi?id=25823
2. poc : https://sourceware.org/bugzilla/attachment.cgi?id=12458
3. target :
4. stack strace
``` log



```
5. about bug 
 
6. patch : 
``` diff


```