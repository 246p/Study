<!DOCTYPE html>
<html>
<head>
<title>11_EC2.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p><a href="https://arxiv.org/pdf/2208.14530.pdf">MC2: Rigorous and Effeicient Directed Greybox Fuzzing</a></p>
<h1 id="abstract">Abstract</h1>
<ul>
<li>기존 DGF는 performance나 optimality에 대한 이론적 분석을 제공하지 않음</li>
<li>DGF를 oracle-guided serach probrem으로 설정하는 complexity-theoritic framwork를 제시</li>
<li>input space에 대한 feedback (ex distance)를 oracle에게 물어본다.</li>
<li>target에 도달하는 input을 찾기 위한 oracle query의 수를 performance metric으로 사용</li>
<li>가능한 input의 수의 log scale에 해당하는 알고리즘을 구현하고 최적임을 증명</li>
<li><em>MC2</em>에 이를 구현</li>
</ul>
<h1 id="1-introduction">1. Introduction</h1>
<ul>
<li>기존에는 CFG distance, branch constraint distance을 사용</li>
<li>이는 직관이나 경험적 증거 (학문적 분석이 없음)</li>
<li>computational complexitytheoretic framework 제시</li>
</ul>
<h1 id="11-complexity-theoretic-framework">1.1. Complexity-Theoretic Framework</h1>
<ul>
<li>DGF의 complexity-theoretic formulation를 제시</li>
<li>instrumentation type및 fuzzing algorithm 에 대한 세부 사항을 추상화 하여 framwork로 전환</li>
<li>DGF -&gt; oracle-guided serach problem으로 모델링</li>
<li>oracle은 serach space에 대한 정보를 fuzzing algorithm에게 알려주어 target reached input을 찾음</li>
<li>프로그램의 동작이나 input/ouput 분포에 대한 가정을 하지 않음</li>
<li>oralce이 쿼리당 크지만 일정한 양의 정보를 가진 내용을 반환하도록함</li>
</ul>
<h2 id="12-execution-complexity">1.2. Execution Complexity</h2>
<ul>
<li>
<p>target site에 도달할때까지 oralce에게 보내는 쿼리의 수로 performance 를 측정</p>
</li>
<li>
<p>우리의 complexity metric은 oracle을 통해 quantum algorithm의 quantum 부분과 classical part를 분리함</p>
</li>
<li>
<p>query complexity : 어떤 알고리즘이 주어진 문제를 해결하기 위하여 얼마나 많은은 질문을 해야 하는가 &gt; 이를 이용하여 알고리즘의 하한선을 정할 수 있고 얼마나 효율적인지 정량적으로 평가할 수 있다.</p>
</li>
</ul>
<p><a href="https://eccc.weizmann.ac.il/report/2021/115/">On Quantum Versus Classical Query Complexity</a></p>
<blockquote>
<p>단 하나도 이해하지 못하였다.</p>
</blockquote>
<p><a href="https://eta.impa.br/dl/043.pdf">Understanding Quantum Algorithms via Query Complexity</a></p>
<blockquote>
<p>양자 알고리즘이 무엇인지 설명</p>
</blockquote>
<ul>
<li>feedback information에 대한 lower bound를 탐구하여 이를 최대한 활용하는 adaptive algorithm을 설계하는 방법을 사용함</li>
</ul>
<h2 id="13-an-optimal-fuzzing-algorithm">1.3. An Optimal Fuzzing Algorithm</h2>
<ul>
<li><em>noisy counting oracle</em>을 도입함</li>
<li>이는 두 input space를 에서 각 영역에서 target site로 도달하는 입력을 대략적으로 계산하고 더 높은 수를 가진 영역이 더 유망한것으로 판단하고 이를 반환한다. (p&lt;0.5의 확률로 거짓을 반환하는 Monte Carlo counting algorithm)</li>
</ul>
<p>시간 복잡도 : $O({{log(N)} \over {(0.5-p)^2}})$ &gt; 이는 다른 알고리즘으로 계선될 수 없음을 증명</p>
<ul>
<li>우리의 fuzzing algorithm은 더 높은 수의 영역을 선택하고 Binary search 로 유망한 영역을 좁혀가는 counting oracle을 사용</li>
<li>하지만 어떤 input space가 더 큰 수를 가지고 있는지 확신할 수 없기 때문에 이러한 noise에 강해야 한다.</li>
<li>따라서 noisy binary search algorithm을 사용하였다.</li>
<li>각 space에 가중치 집합을 사용하여 알고리즘의 정확도를 나타낸다. &gt; 즉 원하는 input이 해당 영역에 존재할 가능성을 나타냄</li>
<li>알고리즘은 각 oracle query에 기반하여 유망한 영역의 가중치를 반복적으로 증가시키며 유망한 input sapce를 좁혀나간다.</li>
</ul>
<h2 id="14-approximate-counting-with-monte-carlo">1.4. Approximate Counting with Monte Carlo</h2>
<ul>
<li>noisy counting oracle을 구현하기위하여 Monte Carlo algorithm 사용</li>
<li>Monte Carlo random sampling은 실제 값이 0이 아닌 작은 수이더라도 대부분의 근사 계산이 0이 될 수 있다.</li>
<li>input space에서 target reach input의 수를 계산하는 것도 매우 작은 확률이기에 0으로 계산된다.</li>
<li>이 문제를 극복하기 위해 우리는 목표에 도달할 수 있는 input을 찾지 못하더라도 더 높은 확신을 가지고 계산에 대한 상한선을 계산할 수 있다는것을 관찰하였다.</li>
</ul>
<h2 id="15-concentration-bounds">1.5. Concentration Bounds</h2>
<ul>
<li>concentration bound를 이용함 &gt; 평균과 분산에 기반하여 랜덤 함수가 특정 값을 가질 확률의 상한을 정하는 방법</li>
<li>branch constraint의 distance를 기반으로 모델링 하면 무작위로 선택된 입력으로 평균과 분산을 계산하면 이 branch를 만족할 가능성에 대한 상한을 구할 수 있다.
하지만 이는 over approximate를 일으킬 수 있다. &gt; 이를 방지하기 위하여 단일 oracle query를 수행할때 어떤 input에 대해서도 만족된적 없는 branch에 대해서만 상한을 적용한다. 나머지에 대해서는 branch를 만족시키는 input의 수와 총 입력수의 경험직 비율을 사용함</li>
</ul>
<h2 id="16-counting-along-multiple-branches">1.6. Counting along Multiple Branches</h2>
<ul>
<li>각 branch를 만족사는 input의 수를 근사하고 이를 통해 목표에 도달하는 입력에 수에 대한 추정치를 얻는다. <a href="#24-noisy-counting-oracle-through-monte-carlo-counting">2.4절</a></li>
<li>Monte Carlo Executionn : runtime에 control flow를 수정하여 외부 branch constraint를 만족하지 않더라도 내부 branch에 방문하도록 함</li>
<li>이를 통해 소수의 프로그램 실행으로 근사할 수 있음</li>
<li>MC2(Monte Carlo Counting)을 구현함</li>
</ul>
<p><img src="./image//11_figure1.png" alt="figure1"></p>
<h2 id="17-contributions">1.7. contributions</h2>
<ul>
<li>DGF를 oracle-guided serach problem으로 정의하는 complexity-theoretic framework를 소개, 알고리즘의 성능을 측정하는 metric인 execution complexity를 도입함</li>
<li>가능한 input의 수에 logarithmic한 execution complexity를 갖는 DGF를 설계하였다.</li>
<li>noisy counting oracle을 구현하기 위한 Monte Carlo algorithm을 구현</li>
</ul>
<h1 id="2-methodology">2. Methodology</h1>
<h2 id="21-terminology-and-notation">2.1. Terminology and Notation</h2>
<ul>
<li>fuzzer = DGF</li>
<li>P = target program</li>
<li>I = 유한한 input space</li>
<li>|·| = cardinality</li>
</ul>
<h3 id="211-input-region">2.1.1. Input Region</h3>
<ul>
<li>WLOG. target program's input space = hyperrectangle I = [0,255]^d, d는 input byte</li>
</ul>
<h3 id="212-control-flow-graph">2.1.2. Control Flow Graph</h3>
<ul>
<li>CFG=(V, E), V = BB, E = control-flow transition (ex branch)</li>
<li>path $\pi$ = finite sequence of edge int CFG $\pi$ : $E_0 \rightarrow  E_1 \rightarrow ... \rightarrow E_k $</li>
</ul>
<h3 id="213-branch-constraint">2.1.3. Branch Constraint</h3>
<ul>
<li>CFG에서 각 edge는 branch constraint에 해당함</li>
<li>$c:I\rightarrow{0,1}$</li>
<li>d(i) : branch distance</li>
</ul>
<blockquote>
<p>Constraint c(i) := d(i) ⊳⊲ 0</p>
</blockquote>
<blockquote>
<p>Predicate ⊳⊲ := {==,&lt;,&lt;=,&gt;,&gt;=}</p>
</blockquote>
<blockquote>
<p>Input i := [$i_1, i_2, ..., i_d$ ]</p>
</blockquote>
<h2 id="22-a-framework-for-directed-greybox-fuzzing">2.2. A Framework for Directed Greybox Fuzzing</h2>
<ul>
<li>실험적인 측정은 이상적인 fuzzer에 얼마나 가까운지 알려주지 못함</li>
<li>program execution 횟수 측면에서 이상적인 fuzzer의 성능에 대한 하한선을 추론하기 위한 complexity theoretic framework 소개</li>
</ul>
<h3 id="221-fuzzing-as-oracle-guided-search">2.2.1. Fuzzing as Oracle-Guided Search</h3>
<ul>
<li>우리의 framwork는 fuzzer가 oracle에 query 하여 input space I 에 대한 정보를 학습</li>
<li>oracle $ O : I \rightarrow {0,1}^c$ , c bit의일정한 크기의 정보를 반환한다.</li>
<li><a href="#23-optimal-directed-fuzzer-with-noisy-counting-oracle">2.3</a>절에서 확인할 수 있듯이 fuzzer는 input의 크기를 $1\over{2^c}$로 줄일 수 있음</li>
<li>실제 fuzzer들은 simbolic/concolic execution이 모든 path constraint를 수집하고 SMT를 호출하는것과 달리 최소한의 execution overhead를 위하여 ligth-weight 한다.</li>
<li>이와 유사한 맥락으로 c를 상수로 정한것은 적합하다.</li>
<li>이 framwork를 일반적으로 사용하기 위하여 target program의 행동이나 input type에 대한 가정 없이 distribution-free하게 작동한다. 또한 fuzzer가 프로그램에 대한 사전 지식 없이 oracle query를 통해 정보를 얻는다고 가정한다.</li>
</ul>
<h3 id="222-problem-definition">2.2.2. Problem Definition</h3>
<ul>
<li>DGF를 oracle-guided search problem으로 정의함</li>
<li>$P, CFG, I, E_T, O:I \rightarrow {0.1}^c$를 이용하여 $E_T$에 도달하는 $i\in I$를 찾아야 함</li>
</ul>
<h3 id="223-execution-complexity">2.2.3. Execution Complexity</h3>
<ul>
<li>fuzzer의 성능을 측정하기 위하여 search problem을 해결하기 위한 oracle의 query의 수를 분석한다.</li>
<li>oracle query의 수는 program execution 수에 직접 mapping 되기 때문에 fuzzer의 성능을 execution complexity로 정의한다.</li>
<li>이를 이용하여 이상적인 fuzzer에 대해 추론할 수 있다. 즉 어떤 fuzzer의 성능에 대한 하한선을 제공한다.</li>
</ul>
<h4 id="theorem-21-lower-bound-for-any-fuzzing-algorithm">Theorem 2.1 (Lower Bound for Any Fuzzing Algorithm)</h4>
<p>query당 C bit의 정보를 드러내는 oracle이 주어졌을때 fuzzing algorithm도 N크기의 input space에서 목표에 도달하는 입력을 찾기 위해서 $\Omega(log(N))$의 execution complexity가 필요하다.</p>
<h3 id="224-greybox-vs-blackbox-oracle">2.2.4. Greybox vs Blackbox Oracle</h3>
<ul>
<li>Blackbox oracle을 이용하여 lower bound에 도달할 수 없다. 여기서 oracle query는 주어진 목표가 도달했는지 여부를 나타내는 bool value만 출력한다. 즉 fuzzer가 고려하는 input의 수를 1만큼 감소시킨다. 즉 O(N)의 실행 복잡도를 갖는다.</li>
</ul>
<h2 id="23-optimal-directed-fuzzer-with-noisy-counting-oracle">2.3. Optimal Directed Fuzzer with Noisy Counting Oracle</h2>
<ul>
<li>noisy counting oracle : 임의의 두 input sapce중에서 target에 도달하는 input의 수를 대략적으로 계산하여 어느 영역이 더 유망하는지 식별</li>
<li>이상적이 환경에서 noise가 없는 counting oracle을 설명한 후 noisy가 있는것을 사용하는 현실적인 설정으로 확장</li>
</ul>
<h3 id="231-noisy-counting-oracle">2.3.1. Noisy Counting Oracle</h3>
<ul>
<li>noisy counting oracle : 목표에 도달하는 input이 더 많은 space에 대해 c=1 bit의 정보를 반환</li>
<li>p&lt;0.5의 확률로 잘못된 답을 반환한다고 가정, input space $I_L, I_R$에 대해 다음 공식을 계산</li>
<li>C(I) = input space I에 속한 input중 target에 도달한 인풋</li>
</ul>
<p><img src="./image/11_formula1.png" alt="formula1"></p>
<p><img src="./image/11_formula2.png" alt="formula2"></p>
<h3 id="232-optimal-deterministic-fuzzer">2.3.2. Optimal Deterministic Fuzzer</h3>
<ul>
<li>이상적인 환경에서 noise가 없는 (p=0) counting oracle을 사용하여 최적의 execution complexity를 달성하는 결정론적 fuzzing algorithm을 제시한다.</li>
<li>binary search를 이용하여 counting oracle을 사용</li>
<li>input space가 여러 바이트를 포함하기 때문에 반으로 나눈다는것이 애매할 수 있음 (ex [0, 255]*[0, 255]의 2byte의 경우 수직, 수평으로 나눌 수 있음)</li>
<li>이를 해결하기 위하여 flatting을 사용함 &gt; [(0, 0), (0, 1), ..., (0, 255), (1,0), (1, 1), ... (255, 255)]</li>
<li>이 알고리즘은 O(log(N))의 execution complexity를 가지며 lower bound에 해당</li>
</ul>
<p><img src="./image/11_algorithm4.png" alt="algorithm4"></p>
<h3 id="233-optimal-randomized-fuzzer">2.3.3. Optimal Randomized Fuzzer</h3>
<ul>
<li>위의 결정론적 알고리즘은 이론적 lower bound를 달성하지만 noise가 없는 counting oralce을 구현하는것이 효율적이지 않음</li>
<li>noisy binary search는 비교가 믿을 수 없다는 가정 하에 binary search를 수행하는 알고리즘을 사용</li>
<li>높은 확률로 성공하되 소수의 query를 요구하는 알고리즘을 개발하는것이 중요하다.</li>
<li>기대 값은 모든 잠재적인 행동을 고려하며 input 분포에 대한 가정을 하지 않는다.</li>
<li>일정 확률로 성공할 수 있는 알고리즘도 여러번 실행된다면 지수적으로 감소하여 작은 값이 된다.</li>
<li>우리는 <em>Ben-Or</em>이 제안한 noisy binary search를 사용하였다.</li>
</ul>
<h4 id="theorem-22-algorithm-1-execution-complexity">Theorem 2.2 (Algorithm 1 Execution Complexity)</h4>
<p>쿼리당 p&lt;0.5의 확률로 식패하는 c=1 bit를 반환하는 noisy counting oracle의 경우 적어도 1-𝛿 확률로 성공하는 O((1-𝛿)*$log(N)\over{(0.5-p^2)}$)의 execution complexity를 갖는다.</p>
<h4 id="theorem-23-algorithm-1-optimality">Theorem 2.3 (Algorithm 1 Optimality)</h4>
<p>위의 조건을 만족하는 어떤 fuzzing algorithm도 동일한 execution complexity를 갖는다.</p>
<p><img src="./image/11_algorithm1.png" alt="algorithm1"></p>
<ul>
<li>query에 따라서 더 많은 input space에 가중치 (1-p)를 곱함, 적은 영역에는 p를 곱합 &gt; 이후 합이 1이되도록 normalization</li>
<li>가중치가 큰 유망한 input space내에서 분할을 우선시함</li>
</ul>
<p>이 알고리즘의 특징</p>
<ol>
<li>noisy counting oracle은 p가 증가함에 지수적이 아닌 2차항으로 저하 된다. &gt; 이는 theorem2.3 에서 보였듯이 개선될 수 없다.</li>
<li>input space I에 대해 공간복잡도가  O(log(N)이다.</li>
</ol>
<h2 id="24-noisy-counting-oracle-through-monte-carlo-counting">2.4. Noisy Counting Oracle through Monte Carlo Counting</h2>
<ul>
<li>Monte Carlo counting을 기반으로 noisy counting oracle을 설계함</li>
<li>graph structure을 활용하여 개별 경로의 합으로 분해한다. 또한 개별 경로 계산을 효율적으로 근사한다.</li>
</ul>
<h3 id="241-monte-carlo-counting">2.4.1. Monte Carlo Counting</h3>
<ul>
<li>일반적인 Monte Carlo counting을 사용한다면 대부분의 영역에 대해 0으로 계산된다.</li>
<li>|I| &gt;&gt; C(I)이기 때문이다.</li>
<li>0으로 추정한 계산을 사용한다면 fuzzer의 성능이 크게 저하될것이다.</li>
</ul>
<h3 id="242-exploiting-cfg-structure-for-counting">2.4.2. Exploiting CFG Structure for Counting</h3>
<ul>
<li>CFG의 graph structure를 이용한다면 C(I)를 개별 경로의 합으로 분해할 수 있다.</li>
</ul>
<p><img src="./image/11_formula3.png" alt="formula3"></p>
<ul>
<li>프로그램에서 경로의 수가 많기 때문에 이 합을 정확하게 계산할 수 없지만 효율적으로 근사 가능하다.</li>
<li>개별 경로에 대한 count로 근사된 count을 추측할 수 있다.</li>
</ul>
<p>Efficiently Approximating Individual Path Counts : uniconstraint count를 사용한다. 또한 계산이 어려운 두가지 우형의 uniconstraint count에 대해 설명한다.</p>
<h3 id="243-approximating-path-counts">2.4.3. Approximating Path Counts</h3>
<ul>
<li>$C_\pi(I)$를 계산하고자 함</li>
<li>이는 여러 단일 brach constraint를 만족하는 input set $I_{E_i}$의 교집합</li>
</ul>
<p><img src="./image/11_formula4.png" alt="formula4"></p>
<ul>
<li>즉 최소 count를 통하여 upper bound를 정할 수 있음</li>
</ul>
<h3 id="244-uniconstraint-counts">2.4.4. Uniconstraint Counts</h3>
<ul>
<li>$C(I_{E_i})$는 $E_i$의 단일 branch constraint를 만족하는 input의 수를 의미 &gt; uniconstraint count 라고 부름</li>
<li>Monte Carlo counting을 통해 uniconstraint count를 근사할 수 있음 &gt; 단일 branch constraint가 여러 branch constraint의 교집합에 비해 count가 더 클 가능성이 높기 때문</li>
</ul>
<p><img src="./image/11_formula5.png" alt="formula5"></p>
<p>r : I를 무작위로 섞어서 추출한 부분 집합에서 $E_i$ 분기 제약을 만족하는 비율</p>
<h3 id="245-challenges-in-approximating-uniconstraint-counts">2.4.5. Challenges in Approximating Uniconstraint Counts</h3>
<ul>
<li>uniconstraint counting은 naive Monte Carlo counting을으로 근사하기 쉽지만 어려운 두가지 유형이 존재한다.</li>
</ul>
<ol>
<li>일부 single branch constraint는 소수의 execution에서 잘못 평가될 수 있다.C1</li>
<li>중첩된 branch에서 평가될 수 없다.</li>
</ol>
<ul>
<li>naive한 MCC는 이와 같은 경우 count = 0 으로 판단</li>
<li>이를 처리하기 위하여 program execution을 늘릴 수 있지만 2.2절에서 언급과 같이 일정수의 프로그램을 내부적으로 실행한다. &gt; 우리가 사전에 얼마나 많은 수의 실행이 필요한지 알 수 없기에 불가능</li>
</ul>
<h3 id="246-c1-handling-evaluated-but-unsatisifed-branches">2.4.6. C1: Handling Evaluated but Unsatisifed Branches</h3>
<ul>
<li>Cheby-shev inequality를 사용하여 concentration bound를 사용하여 uniconstraint counts에 대한 확률적 upper bound를 계산함</li>
<li>프로그램 실행 동안 branch distance의 평균, 분산을 통하여 branch constraint를 만족시킬 확률 r을 설정함</li>
<li>uniconstraint count 자체가 upper bound이기 때문에 Chebt-shev에서도 상한을 사용하는것은 괜찮음</li>
</ul>
<p><img src="./image/11_table1.png" alt="table1"></p>
<ul>
<li>branch constraint에 따라 r을 계산하는 방법 &gt; 오차가 실행 횟수 k에 대해 $1\over{e^k}$로 감소하기 때문에 유효한 근사</li>
<li>이러한 상한은 true count에서 overapproximation error를 발생할 수 있으므로 한번도 만족되지 않는 분기에서만 사용</li>
<li>그렇지 않다면 branch를 만족하는 input의 수와 총 input의 수 사이의 비율을 사용</li>
</ul>
<h3 id="247-c2-handling-unevaluated-nested-branches">2.4.7. C2: Handling Unevaluated Nested Branches</h3>
<ul>
<li>외부의 constraint를 만족하지 않더라도 내부의 branch를 방문하고 평가하도록 하는 <em>Monte Carlo Execution</em></li>
<li>한번의 실행으로 모든 branch를 방문하여 평가함 &gt; 적은 실행으로 모든 분기의 uniconstraint counts를 근사 가능</li>
<li>Monte Carlo Execution은 runtime에 control-flow를 수정하여 input과 관계없이 모든 분기를 방문하도록 함</li>
<li>input이 $\pi$의 모든 branch constraint를 만족하는 경우 &gt; 일반적인 실행</li>
<li>branch constraint중 하나라도 만족하지 않는 경우 원래 path에서 벗어남</li>
<li>항상 sequential odering of compution을 유지</li>
<li>원하는 branch를 방문하는것을 보장하기 위하여 program exception을 조정해야함</li>
</ul>
<blockquote>
<p>input이 array index를 조절한다고 하였을때 범위 밖의 메모리에 접근할 수 있음 &gt; instruction pointer를 진행시키고 읽어오는 값을 무작위 값으로 설정한다.</p>
</blockquote>
<ul>
<li>이와 같은 설계는 읽어오는 값에 대한 집합ㅇ르 증가시키지만 count에 대한 상한을 사용하기 때문에 괜찮다.</li>
<li>memory read, write간의 의존성을 일어버리지만 overhead가 낮다. <a href="#43-rq3-performance-overhead">4.3절</a></li>
</ul>
<p><img src="./image/11_algorithm2.png" alt="algorithm2"></p>
<h3 id="248-efficiently-approximating-the-summation">2.4.8. Efficiently Approximating The Summation</h3>
<ul>
<li>이제까지는 target으로의 단일 path만 고려 &gt; 각 path의 count의 합 : formula 3</li>
<li>path가 많은 경우 oracle query마다 각 path에 대한 계산은 어려움</li>
<li>path별로 더하는 것이 아니라 가장 큰 count로 근사함 &gt; 가장 큰 count를 갖는 경로를 선택하는 것은 다른 path에 비해 합을 가장 잘 보존함</li>
<li>하지만 우리는 어떤 path가 가장 큰 count를 갖는지 사전에 알 수 없기 때문에 초기에 각 경로의 개별 count를 근사하는 일부 계산을 수행 &gt; 하지만 근사 오류로 인한 불확실성 존재</li>
</ul>
<p><img src="./image/11_algorithm3.png" alt="algorithm3"></p>
<ul>
<li>불확실성을 포착하기 위하여 multi-armed bandit literature에서 사용한 소수의 대안 경로를 탐색하기 위한 수정 계수 $\sqrt{log(t)\over{T_\pi}}$ 를 사용 &gt; $T_\pi$는 t번째 query 이전에 $\pi$가 선택된 횟수를 나타냄</li>
<li>PathCache라고 불리는 캐시 구조를 이용하여 가장 최근의 count 정보를 추적</li>
</ul>
<h1 id="3-implementation">3. Implementation</h1>
<h2 id="31-toolchain">3.1. Toolchain</h2>
<ul>
<li>algorithm 1,2,3은 C언어로 구현함 &gt; LLVM instrumentation, signal handler를 사용하여 algorithm 2 처리</li>
<li><em>AFLGo</em>와 같은 forkserver 사용</li>
<li>algorithm 3:19에서 k의 값을 5로 설정 (1/e^5 &lt; 0.01) &gt; algorithm 1의 p값을 0.01</li>
</ul>
<h2 id="32-reducing-loop-overheads">3.2. Reducing Loop Overheads</h2>
<ul>
<li>loop를 사용하면 동일한 branch를 여러번 방문함 &gt; 이를 줄이기 위하여 방문간 정보를 공유함</li>
<li>단일 MCE에서 branch가 여러번 방문된다면 각 방문에서 branch distance는 평균과 분산에 기여함 (streaming mean)</li>
<li>각 branch마다 count 정보를 추가하여 runtime에 여러 방문에 걸친 control-flow를 강제한다.</li>
</ul>
<h2 id="33-assigning-a-total-order">3.3. Assigning A Total Order</h2>
<ul>
<li>input space를 사전 순으로 분할함 &gt; 이는 input space의 어떤 영역이단 counts를 변경할 가능성이 동등하다는 가정</li>
<li>실제 프로그램에서는 동등하지 않다는 실험적 증거로 인해 유효하지 않음</li>
<li>따라서 사전순이 아닌 noisy counting oracle에서 관찰된 program execution을 기반으로 순서를 할당함</li>
<li>byte index set으로 시작하여 2개의 집합으로 분할하고 각 부분집합에 대해 index에 대한 byte값을 변형하며 MCE를 수행</li>
<li>count가 변경되거나 단일 byte index가 남을때까지 이를 반복</li>
<li>각 byte index가 count를 얼마나 증가시키는지에 따라 순서를 할당함</li>
</ul>
<blockquote>
<p>부록 B : 사전순에 비해서 평균 210, 중앙값 54배 빠름</p>
</blockquote>
<h2 id="34-preprocessing">3.4. Preprocessing</h2>
<ul>
<li>목표에 도달하는 모든 path set을 구해야함 &gt; 실제 CFG에서 너무 비싼 runtime을 요구</li>
<li>path의 subset을 생성하는 알고리즘은 반복된 edge의 경로를 생성하지 않아서 loop cjfl qnfrk</li>
<li>우리는 초기 seed corpus를 사용하여 path set을 bootstrap함</li>
<li>목표에 가까운 seed를 실행하고 해당 path를 따라 branch를 무작위로 변형하여 목표에 도달하는 path set을 생성함</li>
<li>path가 반전된 후의 프로그램 실행을 기반으로 path를 생성함</li>
<li>다른 DGF와 MC2의 전처리 과정에 걸리는 시간이 비슷함</li>
</ul>
<h2 id="35-randomly-generating-inputs">3.5. Randomly Generating Inputs</h2>
<ul>
<li>input space를 d차원 hyper rectangle로 표현함, d개의 구간으로 인코딩 되며 각 구간은 차원당 input의 lower, upper bound를 나타냄</li>
<li>우리는 hyper rectangle에서 k개의 input을 무작위로 선택하기 위하여 d개의 정수를 무작위로 생성</li>
<li>초기 시드가 hyper rectangle에 속하는 경우 initial seed corpus 정보를 더 잘 활용하기 우ㅏㅎ여 k개의 입력중 일부로 사용함</li>
<li>seed corpus를 추적하는것이 아닌 group = (hyper rectangle, weight) 튜플을 추적</li>
<li></li>
</ul>
<h1 id="4-evaluation">4. Evaluation</h1>
<ol>
<li>다른 최신 DGF와 비교</li>
<li>실제 버그를 찾을 수 있는가?</li>
<li>성능 오버헤드</li>
<li>design choice가 정당한가?</li>
</ol>
<h2 id="41-rq1-fuzzers-comparison">4.1. RQ1: Fuzzers Comparison</h2>
<ul>
<li>benchmark : magma, AFLGo의 Fuzzer Test suite</li>
<li>baseline : AFLGo, ParmeSan</li>
<li>setup : Magma = TTE, Fuzzer Test suite : TTT, timeout = 6hr, 20회</li>
</ul>
<h3 id="411-magma-results">4.1.1. Magma Results</h3>
<p><img src="./image/11_table2.png" alt="table2"></p>
<h3 id="412-case-study">4.1.2. Case Study</h3>
<p><img src="./image/11_figure2.png" alt="figure2"></p>
<ul>
<li>MC2에서만 발견된 PNG001</li>
<li><code>width=0x55555555</code>, <code>channels=3</code>일때 <code>row_factor</code>가 0이 되어서 divide by zero를 발생</li>
<li>AFLGo는 해당 특정 값을 생성할 확률이 낮음</li>
<li>ParmeSan은 중첩된 조건 (6, 7) 행을 효과적으로 처리하지 못함</li>
</ul>
<h3 id="413-fuzzer-test-suite-results">4.1.3. Fuzzer Test Suite Results</h3>
<p><img src="./image/11_table3.png" alt="table3"></p>
<blockquote>
<p>Result : 평균 134, 중앙값 38배 성능 향상, AFLGo(12)보다 많은 28개의 버그를 찾음</p>
</blockquote>
<h2 id="42-rq2-bug-finding">4.2. RQ2: Bug Finding</h2>
<p><img src="./image/11_table4.png" alt="table4"></p>
<p><img src="./image/11_table5.png" alt="table5"></p>
<ul>
<li>Undefined Behavior Sanitizer를 사용하여 target but를 식별</li>
<li>AFL-CMin으로 중복 제거</li>
</ul>
<blockquote>
<p>Result : 49개의 새로운 bug 찾음</p>
</blockquote>
<h2 id="43-rq3-performance-overhead">4.3. RQ3: Performance Overhead</h2>
<p><img src="./image/11_table6,7.png" alt="table6,7"></p>
<ul>
<li>Monte Carlo Execution의 performance overhead를 측정함</li>
<li>MC2의 데이터 구조 )PathCache)의 메모리 사용량 추적</li>
</ul>
<blockquote>
<p>Result : instrumentatio에서 30% runtime, 4% memory, native execution에 비해 105% runtime, 16% memory overhead</p>
</blockquote>
<h2 id="44-rq4-design-choices">4.4. RQ4: Design Choices</h2>
<p><img src="./image/11_table8,9.png" alt="table8,9"></p>
<ul>
<li>각 design choice의 영향을 측정</li>
</ul>
<h3 id="441-chebyshevs-inequality-for-uniconstraint-counts">4.4.1 Chebyshev’s Inequality for Uniconstraint Counts</h3>
<ul>
<li>Rule-Of-3, Good-Turing을 적용하여 실험 &gt; 결과 Table 8 &gt; MC2의 Chebyshev's inequality는 효과적</li>
</ul>
<h3 id="442-minimum-uniconstraint-count">4.4.2 Minimum Uniconstraint Count</h3>
<ul>
<li>최소 uniconstraint count  vs 모든 constraint의 곱 &gt; 결과 table 9</li>
</ul>
<h3 id="443-path-selection">4.4.3 Path Selection</h3>
<p><img src="./image/11_table10.png" alt="table10"></p>
<ul>
<li><a href="#248-efficiently-approximating-the-summation">가장 큰 count를 갖는 path를 선택할때</a> 의 multi-armed bandit이 아닌 greedy, epsilon-greedy를 적용하여 비교 &gt; 결과 table 10</li>
</ul>
<h1 id="5-related-work">5. Related Work</h1>
<h2 id="51-approximate-counting">5.1. Approximate Counting</h2>
<ul>
<li>SAT formula의 해를 counting하는 것은 많은 곳에서 사용된다.</li>
<li>Approximat Counting은 Monte Carlo 뿐만 아니라 많은 분야에서 사용됨</li>
<li>최근엔 CGF를 위한 seed scheduling에서도 사용됨, graph centrality를 사용하여 실행 가능한 edge의 수를 근사함</li>
<li>MC2(DGF)를 CGF로 일반화 할 연구 필요</li>
</ul>
<h2 id="52-directed-greybox-fuzzing">5.2. Directed Greybox Fuzzing</h2>
<ul>
<li>MC2는 distance가 아닌 noisy binary seach과 aproximate counting을 통하여 guide함</li>
</ul>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$']]},
    messageStyle: "none",
    "HTML-CSS": { availableFonts: "TeX", preferredFont: "TeX" },
  });
</script>
</body>
</html>
