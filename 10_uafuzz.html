<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>0&period; Abstract</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <p><a href="https://www.usenix.org/system/files/raid20-nguyen.pdf">Binary-level Directed Fuzzing for Use-After-Free Vulnerabilities</a></p>
<h1 id="0-abstract">0. Abstract</h1>
<ul>
<li>DF는 추가 정보를 활용하여 bug reproductionm, patch testing, static analysis report verification 등에 사용된다.</li>
<li>UAF와 같은 어려운 취약점은 특히 binary level에서 다루어지지 않고 있다.</li>
<li>우리는 UAF에 집중하는 첫 binary-level DGF <em>UAFuzz</em>를 소개한다.</li>
</ul>
<h1 id="1-background">1. Background</h1>
<h2 id="11-context">1.1. Context</h2>
<ul>
<li><em>AFL</em>, <em>LIBFUZZER</em>와 같은 CGF는 code coverage 정보를 이용하여 input generation을 PUT의 새로운 부분으로 유도하고 많은 program state를 탐색하여 crash를 유발하려고 한다.</li>
<li>DGF는 사전에 선택된 잠대적으로 취약산 target site에 대한 테스트를 수행한다.</li>
<li>DGF의 Bug reproducing에 초점을 맞춘다.</li>
<li>이는 bug report 정보가 제공된 취약점의 Proof-of-Concept(PoC)을 기반으로 입력을 생성한다.</li>
<li>PoC가 제공되더라도 개발자는 regression bug, incomplete fixe의 위혐으로 모든 코너 케이스를 고려해야한다.</li>
<li>bug 가 발생할때 함수 호출 순서(bug stack trace)는 DF를 안내하는데 널리 사용된다.</li>
<li><em>ASan</em>, <em>VALGRIND</em>와 같은 도구에 PoC input으로 code를 실행하면 bug stack trace가 출력된다.</li>
</ul>
<h2 id="12-problem">1.2. Problem</h2>
<ul>
<li>GF는 UAF와 같은 복잡한 취약점을 찾기 어려움</li>
<li>우리는 UAF에 초점을 맞추고 있다.</li>
</ul>
<h2 id="13-goals-and-chllenges">1.3. Goals and chllenges</h2>
<ul>
<li>UAF에 알맞은 DF을 설계함</li>
<li>source code level instrumentation 없이 binary level에서 작동</li>
<li>source code는 항상 사용할 수 없고 부분적으로 제3자 라이브러리에 의존할 수 있기 때문</li>
</ul>
<p>다음과 같은 문제가 존재</p>
<h3 id="131-complexity">1.3.1. Complexity</h3>
<ul>
<li>UAF는 동일한 메모리 위치에서 3가지 event(할당, 해제, 사용)을 유발하는 입력을 생성해야함</li>
<li>PUT의 여러 함수에 걸쳐 있음</li>
<li>시간적 공간적 제약은 만족시키기 어려움</li>
</ul>
<h3 id="132-silence">1.3.2. Silence</h3>
<ul>
<li>UAF는 SEGFAULT와 같은 관찰 가능한 효과가 없을때가 있음</li>
<li>crash만 관찰하는 fuzzer는 testcase가 UAF를 윱라했다는것을 감지하지 못함</li>
<li>runtime overhead로 인하여 <em>ASAN</em>, <em>VALGRIND</em>와 같은 profiling tool을 fuzzing에 사용할 수 없음</li>
</ul>
<p>실제로 최신 DGF <em>AFLGo</em>, <em>HawkEye</em>는 이를 해결할 수 없음</p>
<ul>
<li>UAF의 특징인 temporality를 고려하지 못함</li>
<li>metric의 sequenceness를 고려하지 못함</li>
<li>UAF에 대한 사전 정보가 없기에 많은 seed를 다른 추가 검사를 위해 보냄</li>
<li>source-based DGF는 instrumentation 단계가 오래 걸림</li>
</ul>
<h2 id="14-proposal">1.4. Proposal</h2>
<ul>
<li>UAF에 특화된 binary level DGF인 UAFuzz</li>
<li>DGF의 일반적 구성을 따르지만 UAF의 특성에 맞추어 component를 조정함</li>
</ul>
<p><img src="" alt="table1"></p>
<ul>
<li>
<p>distance matric : target function으로 이어지는 짧은 call chain을 선호, 이는 allocation, free 함수를 포함할 가능성이 높음</p>
</li>
<li>
<p>seed selection : sequenceness-aware target similarity metric</p>
</li>
<li>
<p>power schedule : cut-edge : 전체 target에 도달할 가능성이 높은 perfix path를 선호하는 방법</p>
</li>
<li>
<p>bug triaging 단계에서 seed를 bug가 가능한 것과 아닌것으로 식별하며 프로파일링 도구에 대한 quirie를 많이 줄인다.</p>
</li>
</ul>
<h2 id="15-contributions">1.5. Contributions</h2>
<ul>
<li>UAF에 특화된 첫 DGF 설계 및 3가지 구성요소 (selection heuristic, power schedule, input metrics)에 대한 검토</li>
<li>GF <em>AFL</em>, binary analysis tool platfor <em>BINSEC</em> 위에 구현함</li>
<li>Benchmark test</li>
<li>bug reproduction setting에서 다른 도구 들과 평가</li>
<li>Patch testing에서 효과적임을 입증</li>
</ul>
<h1 id="2-background">2. Background</h1>
<p>이 논문에서 사용되는 몇가지 개념 정리</p>
<h2 id="21-use-after-free">2.1. Use After Free</h2>
<h3 id="211-execution">2.1.1. execution</h3>
<ul>
<li>execution은 input에 의행된 state의 순서</li>
<li>execution trace는 가시적인 오류로 끝날때 crash가 됨</li>
<li>fuzzer의 목표는 crash로 이어지는 input을 찾는것</li>
</ul>
<h3 id="212-uaf-bugs">2.1.2. UAF bugs</h3>
<ul>
<li>더이상 유효하지 않은 heap-allocation object에 대한 pointer dereferncing 할때 발생하는 버그</li>
<li>Double-Free(DF) 는 특수한 case</li>
</ul>
<h3 id="213-uaf-triggering-conditions">2.1.3. UAF-triggering conditions</h3>
<ul>
<li>allocation, free, use 를 순서대로 cover하는 input을 찾아야함</li>
<li>모두 같은 memory object를 참조</li>
<li>마지막 use는 일반적으로 즉시 crash를 일으키지 않음</li>
</ul>
<pre><code class="language-c"><span class="hljs-type">char</span> *buf = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(BUF_SIZE);
<span class="hljs-built_in">free</span>(buf); <span class="hljs-comment">// pointer buf becomes dangling</span>
...
<span class="hljs-built_in">strncpy</span>(buf, argv[<span class="hljs-number">1</span>], BUF_SIZE<span class="hljs-number">-1</span>); <span class="hljs-comment">// UAF</span>
</code></pre>
<h2 id="22-stack-traces-and-bug-traces">2.2. Stack Traces and Bug Traces</h2>
<ul>
<li>stack trace (function call list)를 추출 할 수 있음</li>
<li>이는 program state에 대한 순서를 제공하기 bug reproducing 관점에서 의미 있음</li>
<li>UAF에 대한 carsh는 UAF가 발생한 후 오랜 시간이 지나서 발생하므로 표준 stack trace는 UAF를 재현하는데 도움이 되지 않음</li>
<li><em>ASan, VALGRIND</em>와 같은 동적으로 메모리 손상을 탐지하는 profiling tool의 경우 모든 메모리 관련 이벤트의 stack trace를 기록함</li>
<li>객체가 해제된 후 사용될 때를 감지하면 3개의 stack trace (alloc, free ,use)를 보고 받음 이를 (UAF) bug trace라고 부름</li>
<li>이러한 bug trace를 target이라고 함</li>
</ul>
<p><img src="" alt="figure1"></p>
<h2 id="23-directed-greybox-fuzzing">2.3. Directed Greybox Fuzzing</h2>
<p><img src="" alt="algorithm1"></p>
<h1 id="3-motivation">3. Motivation</h1>
<pre><code class="language-C"><span class="hljs-type">int</span> *p, *p_alias;
<span class="hljs-type">char</span> buf [<span class="hljs-number">10</span>];
<span class="hljs-type">void</span> <span class="hljs-title function_">bad_func</span> <span class="hljs-params">(<span class="hljs-type">int</span> *p)</span> { <span class="hljs-built_in">free</span> (p);} <span class="hljs-comment">/* exit() is missing */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">func</span> <span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> ( buf [<span class="hljs-number">1</span>] == ’F’)
        bad_func (p);
    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* lots more code ... */</span>
}
<span class="hljs-type">int</span> main (<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span> * argv []) {
    <span class="hljs-type">int</span> f = open ( argv [<span class="hljs-number">1</span>] , O_RDONLY );
    read (f , buf , <span class="hljs-number">10</span>) ;
    p = <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
    <span class="hljs-keyword">if</span> ( buf [<span class="hljs-number">0</span>] == ’A’){
        p_alias = <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
        p = p_alias ;
    }
    func() ;
    <span class="hljs-keyword">if</span> ( buf [<span class="hljs-number">2</span>] == ’U’)
        *p = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>12 : 할당, 10 : 헤제, 19 : 역참조를 통하여 UAF 발생</p>
<h2 id="31-bug-triggering-conditions">3.1. Bug-triggering conditions</h2>
<ul>
<li>input의 첫 3byte가 &quot;AFU&quot;일때 발생</li>
<li>alloc, free, use의 이벤트를 순서대로 커버해야 함</li>
<li>crash가 발생하지 않으므로 sanitization 없이 오류를 탐지하지 못함</li>
</ul>
<h2 id="32-coverage-based-graybox-fuzzing">3.2. Coverage-based Graybox Fuzzing</h2>
<p>CGF에서 &quot;AFU&quot;의 input을 생성할 확률은 낮기 때문에 개별 event가 쉽게 트리거 되더라도 UAF event의 순서를 추적하는데 효과적이지 않다.</p>
<h2 id="33-directed-greybox-fuzzing">3.3. Directed Greybox Fuzzing</h2>
<ul>
<li><em>ASan</em>에 의해 주어진 bug trace (14-alloc, 17,6,3-free,19-use)가 주어지면 DGF는 fuzzzer가 원하지 않는 path를 탐색하는것을 방지</li>
<li>DGF는 특정한 순서로 위치에 도달하려고 시도하는것이 아닌 target site를 많이 cover하는 seed를 선호</li>
<li>target (A,F,U)에 대해 A-&gt;F-&gt;U와 U-&gt;A-&gt;F를 구분하지 않음</li>
<li>target site를 탐색할때 순서의 부재는 UAF bug 감지를 어렵개 한다.</li>
</ul>
<h2 id="34-glimpse">3.4. glimpse</h2>
<ul>
<li>우리는 seed selection heuristic을 수정하는데 의존한다.</li>
<li>execution trace가 corver하는 target의 수를 늘린다.</li>
<li>target ordering-aware seed metric</li>
<li><em>AFL</em>에서 &quot;AAAA&quot;와 &quot;AFAA&quot;는 code coverage를 증가시키지 않기때문에 버려짐</li>
<li>하지만 target wsimilarity metric score에 최대값을 가지기 때문에 <em>UAFuszz</em>에서 선택됨</li>
<li><em>AFAA</em>-&gt; <em>AFUA</em>를 생성함</li>
</ul>
<h2 id="35-evaluation">3.5. Evaluation</h2>
<ul>
<li><em>AFLGo</em>는 2시간 내에 버그 탐지 실패</li>
<li><em>UAFuzz</em>는 20분만에 탐지 성공</li>
<li>*VALGRIND에 보내는 입력 또한 낮음</li>
</ul>
<h1 id="4-the-uafuzz-approach">4. The UAFuzz Approach</h1>
<p><img src="" alt="figure2"></p>
<ul>
<li>UAF를 발생하는 control-flow (시간적) runtime(공간적)조건을 모두 충족하는 입력을 찾기</li>
<li>UAF 특성을 적용해서 bug trace에 따라 target에 도달하는 잠재적 inputd</li>
</ul>
<ol>
<li>seed metric</li>
</ol>
<ul>
<li>distance metric : target까지 거리를 근사, 3가지 event를 순서대로 cover할 수 있는지 확인</li>
<li>cut-edge metric : 중요한 node에서 올바른 결정을 내리는지 확인</li>
<li>target similarity mmetric : execution trace가 runtime에 cover하는 target의 수</li>
</ul>
<ol start="2">
<li>seed selection strategy</li>
</ol>
<ul>
<li>runtime에 많은 target을 cover</li>
<li>matric score 기반 power scheduler</li>
</ul>
<ol start="3">
<li>profiling tool</li>
</ol>
<ul>
<li>matric을 이용한 버그 확인을 위하여 <em>VALGRIND</em>를 이용하여 가능성이 높은 PoC input을 사전에 식별하여 불필요한 검사 줄임</li>
</ul>
<h2 id="41-bug-trace-flattening">4.1. Bug Trace Flattening</h2>
<ul>
<li>bug traces는 복잡하여 light-weight intrumentation에 적합하지 않음</li>
<li>bug trace flattening : 통과한 BB의 sequence 추출</li>
</ul>
<p><img src="" alt="figure3"></p>
<ol>
<li>3개의 stak trace를 각 call tree의 path로 보고 stack trace를 병합하여 해당 tree를 재생성함, 여러 child를 가진 node는 UAF event 순서에 따라서 정렬함</li>
<li>preorder traversal을 이용하여 target site에 대한 sequence를 얻음</li>
</ol>
<h2 id="42-seed-selection-based-on-target-similarity">4.2. Seed Selection based on Target Similarity</h2>
<p>우리의 seed selection은 다음 두가지에 기반함</p>
<ol>
<li>DF가 target bug trace cover하는 bug를 찾기 위하여 target bug trace와 유사한 seed 우선</li>
<li>target similarity 는 ordering을 고려해야 한다.</li>
</ol>
<h3 id="421-seed-selection">4.2.1. Seed Selection</h3>
<blockquote>
<p>Defenition 1 : max reaching input</p>
</blockquote>
<p><img src="" alt="algorithm 2"></p>
<ul>
<li>max-reaching input : <code>target bug trace T</code>와 가장 유사한 input</li>
<li>유사도는 <code>target similarity metric t(s,T)</code>에 의해 결정</li>
<li>max-reaching input을 선택하고 mutation 해야 하지만 작은 확률 α(1%, AFL과 동일)로 code coverage를 위한 seed를 선택함</li>
</ul>
<h3 id="422-target-similarity-metrics">4.2.2. Target Similarity Metrics</h3>
<p><img src="" alt="figure4"></p>
<ul>
<li>t(s,T) : seed s의 execution trace와 UAF bug trace T간의 유사성 측정</li>
<li>bug trace의 cover된 target 순서 고려 : P, 아니면 B</li>
<li>3가지 UAF event를 고려 : 3T</li>
<li>target prefix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>P</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_P(s,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> : s가 순차적으로 T에 있는 site cover</li>
<li>UAF prefix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mn>3</mn><mi>T</mi><mi>P</mi></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{3TP}(s,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">TP</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> : s가 순차적으로 T의 UAF event cover</li>
<li>target bag <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_B(s,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> : s가 T에 있는 site cover</li>
<li>UAF bag <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mn>3</mn><mi>T</mi><mi>B</mi></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{3TB}(s,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">TB</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> : s가 T의 UAF event cover</li>
</ul>
<h3 id="423-combining-target-similarity-metrics">4.2.3. Combining Target Similarity Metrics</h3>
<ul>
<li>정밀한 metric P를 사용하는 것은 target으로의 direction을 잘 평가해줌</li>
<li>P의 target bug trace와 일치하는 seed를 구별 할 수 있지만 다른 metricdms qnfrk</li>
<li>덜 정밀한 metric은 정밀한 metric이 제공하지 않는 정보를 제공한다.</li>
<li>P는 figure 2의 UUU와 UFU를 측정하진 않지만 B는 측정한다.</li>
</ul>
<p>이를 모두 적용하기 위하여 사전순으로 다음과 같이 결합함</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>P</mi><mo>−</mo><mn>3</mn><mi>T</mi><mi>P</mi><mo>−</mo><mi>B</mi></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mo>&lt;</mo><msub><mi>t</mi><mi>P</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>t</mi><mrow><mn>3</mn><mi>T</mi><mi>P</mi></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>t</mi><mi>B</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">t_{P-3TP-B}(s,T) := &lt;t_P(s,T),t_{3TP}(s,T),t_B(s,T)&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">−</span><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">TP</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:=&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">TP</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></p>
<p>우선순위</p>
<ol>
<li>prefix에서 많은 위치를 cover하는 seed를 우선시 함</li>
<li>순차적으로 많은 UAF event에 도달</li>
<li>target에 가장 많이 도달하는 seed</li>
</ol>
<p>우리는 기본적으로 P-3TP-B를 사용</p>
<h2 id="43-uaf-based-distance">4.3. UAF-based Distance</h2>
<ul>
<li>seed distance는 DGF에서 중요</li>
<li>기존의 seed distance는 단일 위치에 대해서 계산</li>
<li>UAF는 순서를 고려해야함</li>
<li>우리는 순서를 고려하는 seed distace matric을 제안</li>
</ul>
<h3 id="431-zoom-background-on-seed-distance">4.3.1. Zoom: Background on Seed Distance</h3>
<ul>
<li>AFLGo : seed distance d(s,T)는 execution trace의 각 BB에 대한 기본 블록 거리의 산술 평균으로 정의됨</li>
<li>HawkEye : CG에서 function간 거리를 계산, caller,callee 관계의 가중치를 두어 edge를 결정</li>
</ul>
<h3 id="432-our-uaf-based-seed-distance">4.3.2. Our UAF-based Seed Distance</h3>
<ul>
<li>target site의 순서를 고려함</li>
<li>alloc,free,use 순서를 거치는 path를 선호</li>
<li>light-weight static analysis를 사용하여 event 사이에 가능성있는 CG네의 edge에 가중치를 감소시킴</li>
</ul>
<blockquote>
<p>방법</p>
</blockquote>
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>a</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi></mrow></msub><mo separator="true">,</mo><msub><mi>R</mi><mrow><mi>f</mi><mi>r</mi><mi>e</mi><mi>e</mi></mrow></msub><mo separator="true">,</mo><msub><mi>R</mi><mrow><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{alloc}, R_{free}, R_{use}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal mtight">oc</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">ree</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">se</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>를 계산함 : <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>a</mi></msub><mo separator="true">,</mo><msub><mi>f</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">f_a, f_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 사이의 call edge의 방향을 나타냄</li>
<li>각 방향에 대해 edge를 통해 거쳐갈 수 있는 이벤트의 수를 계산</li>
<li>double free를 감지하기 위하여 두 free event를 도달하는 call edge도 함께 계산</li>
<li>edge가 cover하는 event 수에 기반하여 call edge의 가중치를 감소시킴</li>
<li><em>Hawkeye</em>와 유사하게 edge 가중치를 수정함</li>
</ol>
<p><img src="" alt="expression1,2"></p>
<p><img src="" alt="figure5"></p>
<ul>
<li><em>AFLGo</em>와 유사하게 target에 도달하는 가장 짧은 경로를 선호함</li>
</ul>
<h2 id="44-power-schedule">4.4. Power Schedule</h2>
<ul>
<li><em>AFLGo</em>는 simultated annealing을 사용하여 target에 가까운 seed에 더 많은 energy 할당</li>
<li><em>HawkEye</em>는 trace distance와 function-level similarity를 기반으로 할당</li>
</ul>
<p>우리의 새로운 power schedule은 다음과 같은 직관을 사용함</p>
<ul>
<li>seed가 더 가까운 경우</li>
<li>seed가 target과 더 유사한 경우</li>
<li>target이 중요한 code junction에서 더 나은 결정을 내리는 경우</li>
</ul>
<h3 id="441-cut-edge-coverage-metric">4.4.1. Cut-edge Coverage Metric</h3>
<ul>
<li>세밀한 접근 방식 : target bug trace와 seed execution trace를 BB-level에서 비교 : 높은 runtime overhead 발생</li>
<li>거친 방식 : function-level similarity 측정 &gt; 하지만 target function에 도달한다 하더라도 해당 BB에 도달하진 않음</li>
<li>cut-edge coverage metric : 두 방식의 중간 지점에서 critical decision node에서만 edge level 측정</li>
</ul>
<blockquote>
<p>Definition 2 : cut edge</p>
</blockquote>
<p>두 BB (source, sink) 사이의 cut edge는 decision node에서 나가는 edge이다.</p>
<p><img src="" alt="algorithm3"></p>
<ul>
<li>binary program과 예상 UAF bug trace가 주어졌을때 UAFUZZ에서 cut/non-cut edge를 식별하는 방법</li>
<li>Flatting된 bug trace의 모든  consencutive node 사이의 cut edge를 식별하고 축적</li>
<li>해당 함수 진입 시점부터 call event까지 cut edge를 계산함</li>
<li>flatting 때문에 동일한 함수 내의 다른 점 사이의 cut edge를 계산해야함</li>
</ul>
<p><img src="" alt="algorithm4"></p>
<ul>
<li>단일 함수 내에서 cut edge를 계산하는 방법</li>
<li>source-sink BB 사이의 conditional jump인 critical node를 수집 (data-flow analysis 사용)</li>
<li>critical node의 outgoing edge에 대해 sink BB에 도달할 수 있는지 확인</li>
<li>intra-procedual 이기에 inter-procedual CFG 불필요</li>
</ul>
<p>더 많은 cut edge를 실행하는 입력이 target의 더 많은 위치를 커버할 가능성이 높다는 것</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>c</mi></msub><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E_cut(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> : UAF bug trace T가 주어진 프로그램의 모든 cut edge set</p>
<p>s의 cut edge score <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e_s(s,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>를 다음과 같이 정의</p>
<p><img src="" alt="expression 3"></p>
<ul>
<li>hit(e) : edge e가 실행되는 횟수</li>
<li>δ : non-cut edge를 cover하는 것에 대한 페널티 가중치</li>
<li>loop에 의한 path explosion을 방지하기 위하여 buketized를 사용함</li>
</ul>
<h3 id="442-energy-assignment">4.4.2. Energy Assignment</h3>
<p>sadf</p>
<h2 id="45-postprocess-and-bug-triage">4.5. Postprocess and Bug Triage</h2>
<h1 id="5-implementation">5. Implementation</h1>
<h1 id="6-experimental-evaluation">6. Experimental Evaluation</h1>
<h2 id="61-resarch-question">6.1. Resarch Question</h2>
<h2 id="62-evaluation-setup">6.2. Evaluation Setup</h2>
<h2 id="63-uaf-bug-reproducing-ability-rq1">6.3. UAF Bug-reproducing Ability (RQ1)</h2>
<h2 id="64-uaf-overhead-rq2">6.4. UAF Overhead (RQ2)</h2>
<h2 id="65-uaf-triage-rq3">6.5. UAF Triage (RQ3)</h2>
<h2 id="66-individual-contribution-rq4">6.6. Individual Contribution (RQ4)</h2>
<h2 id="67-patch-testing-and-zero-days">6.7. Patch Testing and Zero-days</h2>
<h2 id="68-threat-to-validity">6.8. Threat to Validity</h2>
<h3 id="681-implementation">6.8.1. Implementation</h3>
<h3 id="682-benchmark">6.8.2. Benchmark</h3>
<h3 id="683-competitors">6.8.3. Competitors</h3>
<h1 id="7-related-work">7. Related Work</h1>
<h2 id="71-dgf">7.1. DGF</h2>
<h2 id="72-cgf">7.2. CGF</h2>
<h2 id="73-uaf-detection">7.3. UAF Detection</h2>
<h2 id="74-uaf-fuzzing-benchmark">7.4. UAF Fuzzing Benchmark</h2>
<h1 id="8-conclusion">8. Conclusion</h1>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>