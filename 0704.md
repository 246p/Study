[Sound Input Filter Generation for Integer Overflow Errors](https://www.cs.toronto.edu/~fanl/papers/sift-popl14.pdf)

# 1. 개요
## 1.1. 기존 Input filter의 문제 (unsoundness)
- execution path를 기반으로 FSE를 사용하여 vulnerability signature 찾음
- loop unroling을 사용 > 가능한 execution path의 subset만 분석
- aliased value를 고려하지 않음

## 1.2. SIFT
- critical site(allocation, block copy)의 critical expression (크기 계산) 에서 INT OF가 발생하는지 체크해주는 filter 
- inter procedural, demand-driven, weakest precondition static analysis 사용
- critical expression의 value에 기여하는 모든 expression의 symbolic condition
- path를 고려하지 않기에 sound > 특징
1. critical site로 가는 path를 정확하게 다 찾을 수 없음
2. conditional statement를 무시하기 때문에 overhead가 적음
3. safety check 까지 무시하기 때문에 안전한 input을 filtering 가능함 (incomplete)
- overhead가 낮고 false postive가 없음 (sound)
## 1.3. Pointer analysis
- potential aliasing relationship을 분석하여 equivalence set으로 grouping
- arbitary off-the-shelf alias or pointer analysis와 precondition generation algorithm을 통합
- fixed point analysis를 사용하여 loop invariants를 얻음 (찾을 수 없다면 10회 반복)
## 1.4. SIFT Usage Model
1. Module Identification : input을 처리하는 moudle을 식별, 해당 module에 대한 input filter 생성
2. Critical Site Identification : module을 scan하여 ciritical site를 식별
3. Static Analysis : ciritical exprssion에 대해 demand-driven backward SA를 통해 symbolic condition 도출

# 2. Example
## 2.1. Swfdec 0.5.5

![figure1](./image/20_figure1.png)
- jpeg_decoder_decode : JPEG 디코딩
- jpeg_decoder_start_frame : image metadata를 읽음
- jpeg_decoder_init_decoder : JPEG에 대한 메모리 buffer 할당
- line 43~47에서 Swftdec에서 INT OF 취약점 존재

![figure2](./image/20_figure2.png)

- demand-driven interprocedual backward SA를 통해 figure2의 symbolic condition C를 계산함
- safe(e) : e를 계산하는 과정에 OF 발생하지 않아야함
- sext(v, w) : v를 w로 확장
- 실제로는 부호도 추적하지만 figure 2에는 이를 생략

## 2.2. Challenge

- 버퍼의 크기를 계산하는 식은 `h_sample, v_sample`의 최대 값인 `max_h_sample, max_v_smaple`을 사용
- 이 변수가 어떤 instance를 나타내는지 정적으로 결정하는것은 불가능함 > 해당 input field의 모든 instance를 나타내는 추상화 수행
- input field를 읽는 함수와 할당하는 함수가 다름 > interprocedual analysis

# 3. Static Analysis
- LLVM Compiler Infrastrucutre를 사용
## 3.1. Core Language and Notation

![figure3](./image/20_figure3.png)

![figure4](./image/20_figure4.png)

- firstS(s) : s의 첫번째 statement, firstL(s) : s의 첫번째 label 
- last(s) : s의 마지막 label
- labels(s) : s의 label의 집합, load sotre는 LoadLabel, StoreLabel 을 사용하여 표현
- load, store 에서 alias를 구분하기 위하여 LLVM pointer analysis pass, DSA pointer pass 사용


## 3.2. Intra-procedural Analysis
- critical site 에서 변수 v로 시작하여 backward propagation
- input field value -> v의 값을 계산 하는 방식중 symbolic condition을 계산 > 이 과정에 INT OF 발생 확인

### 3.2.1. Condition Syntax
![figure5](./image/20_figure5.png)

### 3.2.2. Abstraction for Input Field Instantiations
- symbolic condition C에서 f\<id>는 input field의 임의의 instantiation를 나타냄, id를 통해 구분 가능
### 3.2.3. Abstraction for Values Accessed via Pointers
- l\<id>는 load 명령이 반환한 값 > id를 통해 구별
- abstraction을 통해 시작 위치에서 propagation 된 지점까지의 label l에서 역참조된 포인터의 모든 alias를 저장
### 3.2.4. Analysis Framework
- s : statement sequence
- l : s 내부의 label
- C : l 직후의 symbolic condition
- F(s,l,C)를 계산함 > s statement 이후 C가 성립을 보장 > hoare logic과 유사
- 따라서 우리는 f(s0, l, safe(v))를 만족하는지 확인하는 input filter (s0는 주어진 프로그램, l : critical site)