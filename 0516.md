# BEACON

[BEACON : Directed Grey-Box Fuzzing with Provable Path Pruning](https://qingkaishi.github.io/public_pdfs/SP22.pdf)

## 2.2. Problem and Challenges : infeasible-path-explosion problem
- BEACON : 적은 overhead로 infeasible path를 pruning
- intermediate program state를 weakest precondition으로 근사하여 계산하여 execution을 허용한다.
- CFG에서 target l, 위치 p가 주어졌을떄 wp(p,l) : l에 rechable을 보장하는 가장 러프한 precondition
- p에 도달하지만 wp(p,l)을 만족하지 않는 path는 제거된다.

> challenge
1. precondition inference 에서 path condition에 대해 효율적으로 추론하는방법
2. merging path에서 정밀도 손실을 피하면서 precision loss를 피하는 방법

## 3.1. Backward Interval Analysis
- static하게 계산된 control flow information으로 프로그램을 slicing 함
- wp를 추론하기 위하여 backward interval analysis를 수행
- 정확한 weakest precondition 을 계산할 수 없기에 predefined abstract domain에 대한 sound abstraction을 계산함 (over approximation) > interval domain > 변수간의 상호작용을 고려하지 않음 
> 부정확성을 악화시키는 두가지 해결
1. Relationship Preservation
- 변수간의 관계를 보존한다면 정확한 precondition을 얻을 수 있음 
2. Bounded Disjunction
- 전통적인 방법은 서로 다른 path에서의 SA결과를 병합함 > 부정확성 발생
- SA 결과에 대한 제한적 Disjoint를 유지하고 path의 수가 임계값을 넘을때만 병합함 (구현에서 5)
- 임계값에서 병합할때 어떤식으로 병합하는지에 따른 문제도 있음
## 3.2. Selective Instrumentation
- PUT의 모든 statement를 intrumentation 하는 것은 cost가 많이듬
- BEACON은 변수 정의, branch에 대해서만 intrumentation
- precondition을 포함하는 assertion을 삽입함

### 4.1.1. Language
![figure4](./image/16_figure4.png)

## 4.2. Backward Interval Analysis
- target location $l_0'$이 주어질때 target에 도달하기 위한 precondition set $\hat{wp}(l,l_0')$을 계산
- path condition을 추론하기 위하여 $\alpha, \gamma$를 사용
- target site에서 시작하는 역방향 path를 over-approximate 해야함 > worklist = (instruction, postcondition) 사용

![algorithm2](./image/16_algorithm2.png)
- line3 : target t와 initial postcondition `true`를 worklist에 추가 
- line 5-6 : work list에서 $(<l,i,l'>,\phi)$를 pop 하여 instruction i에 따라 postcondition $\phi$ 변환
- 새로 계산된 postcondition $\phi'$은 $\hat{wp}(l)$의 값을 update하기 위하여 역방향 전파
- predicate transformer 와 worklist가 모든 execution을 추적하여 backworld path를 추론할 수 있음

![figure2](./image/16_figure2.png)

- $l_{18} -> l_{14} backworld analysis$를 진행하여 line 9에서 p1, p2로 분기됨
- line 8 에서 p1, p2의 condition은 다음과 같음
- pc1 : {z<2y, v<6, x<40, v=y-x, w<5, x>=20}
- pc2 : {z<2y, v<6, x<40, v=y-x, w>25, x<20}
- 이를 해결하기 위해서 SMT solver를 사용하는 것은 cost가 높음
- line 8 에서 다시 두 path가 합쳐지므로 적당한 정밀도 손실을 유지하며 $\hat{wp}(l_8)$로 결합되어야함
- 이를 위하여 적당한 interval abstraction 사용 
- $\alpha = \Lambda : V -> Interval $, Interval = integear 사이의 집합, $\top$ = Z, $\bot$ = 공집합
- $\gamma(\Lambda) = \cap_{v\in dom(\Lambda)}cons(v)$ : abstract value를 logical constraint로 mapping

![formula1](./image/16_formula1.png)

- interval abstraction으로 다양한 backword path를 건전하게 결합함

![abstract1](./image/16_abstract1.png)

- `joinPath`에서 pc1, pc2의 interval abstraction을 결합
- interval abstraction은 부정확 할 수 있음 > 정밀도를 향상시키는 두가지 최적화
1. 특정 변수간 관계를 명시적으로 추적하는 interval abstraction $\alpha$ 설계
2. 결합을 수행할 시기와 방법을 결정하는 bounded disjuction strategy 설계


## 4.3. Optimizations for Maintaining Precision
### 4.3.1. Relationship Preservation
- top-down analysis
- interavl abstraction $\alpha$는 path condition에 나타내는 변수들의 범위를 추론하는데 사용됨
- 변수 뿐만 아니라 path condition에 나타나는 expression의 interal 또한 추적 > 이를 child, parent에 전파하여 정밀도 상승

![figure5](./image/16_figure5.png)

- 7,8 : interval abstactionn의 정밀도를 증가시키는 heuristic

![figure6](./image/16_figure6.png)
- pc2에서 새로운 추론규칙을 사용 : 더 정밀한 결과

### 4.3.2. Bounded Disjunctions
- 다른 path에서 전파된 조건을 선택적으로 결합하여 정밀도를 높일 수 있음
- backword propagation 동안 정밀도를 유지하기 위한 bounded dijunctions 전략 설계
- bound threshold를 사용하여 l에 도달하는 path의 수가 threshold 적을때 condition들을 $\hat{wp}(l)$에서 유지
- 개별적으로 backword propagate

![figure7](./image/16_figure7.png)
- interval abstraction을 통해 정밀도 손상이 발생할 수 있음
- 두 abstract region의 교차는 frechet distance로 측정할 수 있음
- interval domain에서 각 변수의 interval 에서 distance를 누적하여 정밀도 손실을 계산해야함

![formula2](./image/16_formula2.png)
- v = path condition $\phi_1, \phi_2$의 공유 변수
- $v_{\phi_1} = [l_1, u_1], v_{\phi_2} = [l_2, u_2]$

![formula3](./image/16_formula3.png)

![formula4](./image/16_formula4.png)

## 4.4. Precondition Instrumentation
- target program location에서 rechable을 위한 precondition을 추론 > 이를 program에 instrumentation 하여 runtime에 infeasible path pruning
- 정교한 분석 > instrumentation, runtime에 overhead > 선택적으로 instrumentation 해야함
1. SSA form으로 변환하여 변수 정의만 instrumentation의 후보 위치
2. v1의 값이 v2에 의존하는 경우 v1은 instrumentation 되지 않음
# 5. Evalutation
- LLVM을 기반으로 BEACON 구현
- PUT를 LLVM bit code로 compile, precondition analysis, instrumentation, coverage 관련 instrumentation이 수행됨
- 이후 LLVM bit code를 executable binary로 compile하여 AFLGo를 fuzzing engine으로 사용
1. 4가지 DGF와 비교
2. path slicing, precondition 확인이 fuzzing 시간을 얼마나 단축하는지 평가
3. precondition analysis가 relational preservation, bounded disjunction의 영향 평가
4. instrumentation에 의한 runtime overhead의 측정으로 instrumentation 전략의 효과 평가 

- Baselines : AFLGo, Hawkeye, AFL, Mopt, AFL++
- Benchmarks

![table2](./image/16_table2.png)

## 5.1. Compared to the State of the Art
![table3](./image/16_table3.png)
## 5.2. Impacts of Path Slicing & Precondition Checking
![figure10](./image/16_figure10.png) 
## 5.3. Impacts of Relation Preservation & Bounded Disjunction
![figure11](./image/16_figure11.png)
## 5.4. Instrumentation Overhead
![table6](./image/16_table6.png)
## 5.5. Case Study
![figure12](./image/16_figure12.png)
- line 12에서 crash 발생 가능
- line 5 앞에 precondition 삽입 > 조기 종료 가능
## 5.6. Discussion
### Assisting other fuzzers
- 일반적인 DGF는 input generation, seed prioritization 을 통하여 성능 향상
- BEACON은 fuzzing의 무작위성을 완화시킴
### Threats to validity
- input generation의 무작위성에 의해서 실험 결과에 영향을 미칠 수 있음
- BEACON이 SE를 지원하는 fuzzer를 지원하기 힘듬 (확장성의 문제)
# 6. Related Work
## 6.1. Directed White-box Fuzzing
- DF는 SE, Concolic execution에 의존하는 WF에서 시작됨
- SE를 통해 탐색할 program path의 priority 정하기 가능
- SE자체 속도 가속화
## 6.2. Coverage-guided Fuzzing
- dynamic taint analysis를 사용하여 input generation optimize 가능
- SE와 함께 사용하는 hybrid fuzzing
# 7. Conclusion
- BEACON은 path pool에서 GF를 유도하여 불필요한 execution을 피하고 시간을 절약
- 저비용, 정밀한 분석을 통한 infeasible path에 대한 pruning


# 2. CAFL

