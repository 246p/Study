# BEACON

[BEACON : Directed Grey-Box Fuzzing with Provable Path Pruning](https://qingkaishi.github.io/public_pdfs/SP22.pdf)

## 2.2. Problem and Challenges : infeasible-path-explosion problem
- BEACON : 적은 overhead로 infeasible path를 pruning
- intermediate program state를 weakest precondition으로 근사하여 계산하여 execution을 허용한다.
- CFG에서 target l, 위치 p가 주어졌을떄 wp(p,l) : l에 rechable을 보장하는 가장 러프한 precondition
- p에 도달하지만 wp(p,l)을 만족하지 않는 path는 제거된다.

> challenge
1. precondition inference 에서 path condition에 대해 효율적으로 추론하는방법
2. merging path에서 정밀도 손실을 피하면서 precision loss를 피하는 방법

## 3.1. Backward Interval Analysis
- static하게 계산된 control flow information으로 프로그램을 slicing 함
- wp를 추론하기 위하여 backward interval analysis를 수행
- 정확한 weakest precondition 을 계산할 수 없기에 predefined abstract domain에 대한 sound abstraction을 계산함 (over approximation) > interval domain > 변수간의 상호작용을 고려하지 않음 
> 부정확성을 악화시키는 두가지 해결
1. Relationship Preservation
- 변수간의 관계를 보존한다면 정확한 precondition을 얻을 수 있음 
2. Bounded Disjunction
- 전통적인 방법은 서로 다른 path에서의 SA결과를 병합함 > 부정확성 발생
- SA 결과에 대한 제한적 Disjoint를 유지하고 path의 수가 임계값을 넘을때만 병합함 (구현에서 5)
- 임계값에서 병합할때 어떤식으로 병합하는지에 따른 문제도 있음
## 3.2. Selective Instrumentation
- PUT의 모든 statement를 intrumentation 하는 것은 cost가 많이듬
- BEACON은 변수 정의, branch에 대해서만 intrumentation
- precondition을 포함하는 assertion을 삽입함

### 4.1.1. Language
![figure4](./image/16_figure4.png)

## 4.2. Backward Interval Analysis
- target location $l_0'$이 주어질때 target에 도달하기 위한 precondition set $\hat{wp}(l,l_0')$을 계산
- path condition을 추론하기 위하여 $\alpha, \gamma$를 사용
- target site에서 시작하는 역방향 path를 over-approximate 해야함 > worklist = (instruction, postcondition) 사용

![algorithm2](./image/16_algorithm2.png)
- line3 : target t와 initial postcondition `true`를 worklist에 추가 
- line 5-6 : work list에서 $(<l,i,l'>,\phi)$를 pop 하여 instruction i에 따라 postcondition $\phi$ 변환
- 새로 계산된 postcondition $\phi'$은 $\hat{wp}(l)$의 값을 update하기 위하여 역방향 전파
- predicate transformer 와 worklist가 모든 execution을 추적하여 backworld path를 추론할 수 있음

![figure2](./image/16_figure2.png)

- $l_{18} -> l_{14} backworld analysis$를 진행하여 line 9에서 p1, p2로 분기됨
- line 8 에서 p1, p2의 condition은 다음과 같음
- pc1 : {z<2y, v<6, x<40, v=y-x, w<5, x>=20}
- pc2 : {z<2y, v<6, x<40, v=y-x, w>25, x<20}
- 이를 해결하기 위해서 SMT solver를 사용하는 것은 cost가 높음
- line 8 에서 다시 두 path가 합쳐지므로 적당한 정밀도 손실을 유지하며 $\hat{wp}(l_8)$로 결합되어야함
- 이를 위하여 적당한 interval abstraction 사용 
- $\alpha = \Lambda : V -> Interval $, Interval = integear 사이의 집합, $\top$ = Z, $\bot$ = 공집합
- $\gamma(\Lambda) = \cap_{v\in dom(\Lambda)}cons(v)$ : abstract value를 logical constraint로 mapping

![formula1](./image/16_formula1.png)

- interval abstraction으로 다양한 backword path를 건전하게 결합함

![abstract1](./image/16_abstract1.png)

- `joinPath`에서 pc1, pc2의 interval abstraction을 결합
- interval abstraction은 부정확 할 수 있음 > 정밀도를 향상시키는 두가지 최적화
1. 특정 변수간 관계를 명시적으로 추적하는 interval abstraction $\alpha$ 설계
2. 결합을 수행할 시기와 방법을 결정하는 bounded disjuction strategy 설계


# 2. CAFL