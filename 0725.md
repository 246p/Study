# 0. TODO
- 먼저 지난번 미팅때 SIFT 논문의 precondition analysis에 대해 예제를 가지고 논의해 보기로 했는데, 보다 자세하게 가이드라인을 주겠습니다:
- 예제 코드를 CFG 형태로 표현하고, CFG를 거꾸로 타고 올라가면서 precondition이 어떻게 계산되는지 보이는 방식으로 설명을 부탁합니다.
- 예를 들면 조건문의 경우 아래와 같은 코드를 CFG로 표현한 다음에 거꾸로 올라가면서 각 지점에서 precondition이 어떻게 계산되는지 보여주면 됩니다.

```c
if (x == 10) { 
  s = y;
} else { 
  s = z;
}
memcpy(... , ..., s); // Critical expression은 변수 "s"
```


# 1. Store preciodition (may-alias)

- Store 명령에 대하여  왜 precondition 분석이 그렇게 정의되는지 (특히 may-alias의 경우) 보여주는 예제
``` c

```

# 2. loop (fixpoint)

- 반복문의 경우에 어떤 경우에 fixpoint 도달이 가능하고, 어떤 경우에 그렇지 않은지 보여주는 각각의 예제
``` c

```
# 3. function call
- 함수 호출의 경우 왜 precondition 분석이 그렇게 정의되는지 보여주는 예제
``` c

```

# 4. PNG003
- CVE-2015-8126, CVE-2015-8472
- png_set_PLTE, png_get_PLTE에서 BOF


```c
// pngrutil.c:1065
   png_set_PLTE(png_ptr, info_ptr, palette, num);

//pngset.c:571
void PNGAPI
png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,
    png_const_colorp palette, int num_palette)
{

   png_uint_32 max_palette_length;

   png_debug1(1, "in %s storage function", "PLTE");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   max_palette_length = (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
      (1 << info_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;

#ifdef MAGMA_ENABLE_FIXES
   if (num_palette < 0 || num_palette > (int) max_palette_length)
#else
   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)
#endif
   {
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         png_error(png_ptr, "Invalid palette length");

      else
      {
         png_warning(png_ptr, "Invalid palette length");

         return;
      }
   }

   if ((num_palette > 0 && palette == NULL) ||
      (num_palette == 0
#        ifdef PNG_MNG_FEATURES_SUPPORTED
            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0
#        endif
      ))
   {
#ifdef MAGMA_ENABLE_FIXES
      png_error(png_ptr, "Invalid palette");
#else
      png_chunk_report(png_ptr, "Invalid palette", PNG_CHUNK_ERROR);
      return;
#endif
   }

   /* It may not actually be necessary to set png_ptr->palette here;
    * we do it for backward compatibility with the way the png_handle_tRNS
    * function used to do the allocation.
    *
    * 1.6.0: the above statement appears to be incorrect; something has to set
    * the palette inside png_struct on read.
    */
   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);

   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
    * of num_palette entries, in case of an invalid PNG file or incorrect
    * call to png_set_PLTE() with too-large sample values.
    */
   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,
       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));

   if (num_palette > 0)
      memcpy(png_ptr->palette, palette, (unsigned int)num_palette *
          (sizeof (png_color)));
   info_ptr->palette = png_ptr->palette;
   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;

   info_ptr->free_me |= PNG_FREE_PLTE;

   info_ptr->valid |= PNG_INFO_PLTE;
}

```

``` c
// pngrutil.c:1000 : num만큼 반복, palette가 그것보다 작다면 buffer overflow
#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      pal_ptr->red = buf[0];
      pal_ptr->green = buf[1];
      pal_ptr->blue = buf[2];
   }



// RDIj.c:196
/* Read data, and (optionally) run it through the CRC. */
void /* PRIVATE */
png_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)
{
   if (png_ptr == NULL)
      return;

   png_read_data(png_ptr, buf, length);
   png_calculate_crc(png_ptr, buf, length);
}


// pngrio.c:32
void /* PRIVATE */
png_read_data(png_structrp png_ptr, png_bytep data, size_t length)
{
   png_debug1(4, "reading %d bytes", (int)length);

   if (png_ptr->read_data_fn != NULL)
      (*(png_ptr->read_data_fn))(png_ptr, data, length);

   else
      png_error(png_ptr, "Call to NULL read function");
}

// pngread.c :1586
    image->opaque->png_ptr->read_data_fn = png_image_memory_read;


// pngread.c :1541 : image->opaque에서 가져옴
static void PNGCBAPI
png_image_memory_read(png_structp png_ptr, png_bytep out, size_t need)
{
   if (png_ptr != NULL)
   {
      png_imagep image = png_voidcast(png_imagep, png_ptr->io_ptr);
      if (image != NULL)
      {
         png_controlp cp = image->opaque;
         if (cp != NULL)
         {
            png_const_bytep memory = cp->memory;
            size_t size = cp->size;

            if (memory != NULL && size >= need)
            {
               memcpy(out, memory, need);
               cp->memory = memory + need;
               cp->size = size - need;
               return;
            }

            png_error(png_ptr, "read beyond end of data");
         }
      }

      png_error(png_ptr, "invalid memory read");
   }
}

```