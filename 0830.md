# build

# binutils-2.26


# libming-0.4.8
## swftophp
``` sh
swftophp_SOURCES = outputscript.c main.c
outputscript.c > include "decompile.c, outputscript.patch
```
- ming-0_4_8 ~ lastest 변경하상
```log
fbbb6f82 decompile: fix loop cond issue leading to OOB read
6e5a28dc decompile: introduce new method Offset
0aab70a3 decompile: fix null pointer dereference in newVar3
efc75c28 decompile: fix buffer-overflow in getString
1d698a4b decompile: fix use-after-free in decompileJUMP
dc65ba04 decompile: Fix null pointer dereference in getInt
da9d86ea decompileAction: Prevent heap buffer overflow and underflow with using OpCode
6f1ab314 Perform deep copy in pushdup (instead of shallow)
30170828 Fix heap-buffer-overflow in getString
8dd118ea Fix null pointer dereference in getName/getString
3a000c7b Fix heap-buffer-overflows when accessing pool
9c53bf8e Use OpCode instead of directly accessing actions
f42fdb48 Fix heap-use-after-free in decompileIF
726c2768 Fix buffer overflow in dcputs (buffer missing \0)
8b29e8e7 Un-define DEBUGSTACK (util/decompile.c)
eda5a202 Fix null-pointer dereference issue in stackswap.
1f597633 Fix heap buffer overflow in decompileCALLFUNCTION
2027b24f Fix various overflows in OpCode and readBytes
7fed3147 Fix various overflows in util/ (CVE-2017-11704)
```
```log
commit fbbb6f82199de42110c0299e50c5b2f81d8897f4
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Sat Jun 30 14:15:08 2018 -0400

    decompile: fix loop cond issue leading to OOB read
    
    In decompileSETTARGET a while loop is used to count the number of
    operations until a certain type of operation has been reached. This
    loop uses action_cnt+n < maxn as stop condition, meaning that
    action_cnt+n = maxn might be true after the loop.
    
    This is wrong because action_cnt is used as the number of operations
    to process in an array of maxn-n-1 elements.
    
    Fix the loop's stop condition and switch to for loop for better
    readability.
    
    This patch is the second part of the CVE-2018-11226 fix (fixes: #144).

commit 6e5a28dc0419e5c6681292db40cbd996fadf9213
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Sun Jun 10 16:33:29 2018 -0400

    decompile: introduce new method Offset
    
    The getString method in decompile.c is vulnerable to a buffer
    overflow which can be triggered using a crafted SWF file.
    
    This vulnerability is the consequence of unchecked accesses to the
    actions array when getting the offset of SWF_ACTIONRECORD objects.
    
    This pattern is present a bit everywhere in the source code, leading
    to a large number of potential flaws similar to this one. In this
    commit we introduce a new Offset method similar to the OpCode method
    which handles bound checking when retrieving the offset of
    SWF_ACTIONRECORD objects.
    
    This commit also modifies getString to use this newly introduced
    method and address the previously explained bug.
    
    Usage of the newly introduced Offset method will be generalized in a
    future commit.
    
    Please, note that this commit won't be sufficient to fix #144
    (CVE-2018-11226) since another issue is triggered by the same sample.

commit 0aab70a3020dd8b4fad66b20995fc691f24a0317
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri May 25 22:45:22 2018 -0400

    decompile: fix null pointer dereference in newVar3
    
    getString (indirectly called by getName) is passed a variable of non
    standard type 10 (= "PUSH_VARIABLE"), which seems to return the
    string contained in passed variable, without quotes. If contained
    string is NULL, a NULL pointer is returned, which later causes NULL
    pointer dereference.
    
    In this patch we address this issue such that if the variable contains
    an invalid string, we act just like in the PUSH_STRING case. Otherwise
    a copy of the string is returned.
    
    Fixes: #118 (CVE-2018-7866).

commit efc75c28e89fe864cf0412d5a5f0b4a451e14509
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri May 25 22:39:12 2018 -0400

    decompile: fix buffer-overflow in getString
    
    getString prints a 32 bit integer to a 10 char buffer, but the number
    itself has 10 digits so there's an overflow.
    
    Similar to #116, same fix.
    
    Fixes #111, CVE-2018-7873.

commit 1d698a4b1f03d6136bbf2b0171b86985be553454
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri May 25 22:22:33 2018 -0400

    decompile: fix use-after-free in decompileJUMP
    
    Same issue as f42fdb4 (functions accessing actions array without
    checking the validity of n, the user entered index), same fix.
    
    In this patch we also fix other source code places which might be
    affected by the same bug.
    
    Fixes #131 (CVE-2018-9009).

commit dc65ba0497f4c5ca58be2018e2816e72baf63634
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri May 25 22:11:51 2018 -0400

    decompile: Fix null pointer dereference in getInt
    
    When getInt is passed a PUSH_REGISTER parameter, it retrieves the
    content of this register and returns the value contained by this
    register as an int. When this register is empty, we call getInt with
    a NULL pointer and a null pointer dereference occurs.
    
    In this patch we first make sure that regs[act->p.RegisterNumber] is
    not NULL before doing anything with it.
    
    Fixes #133 (CVE-2018-9132).

commit da9d86eab55cbf608d5c916b8b690f5b76bca462
Author: Young Xiao <YangX92@hotmail.com>
Date:   Sat Mar 16 17:42:14 2019 +0800

    decompileAction: Prevent heap buffer overflow and underflow with using OpCode

commit 6f1ab314684423be5c8bf29c73f65fadfbe71382
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Sun Apr 1 09:46:12 2018 -0400

    Perform deep copy in pushdup (instead of shallow)
    
    Until now, the element duplication in pushdup was performed via
    t->val = Stack->val.
    
    While this is perfectly fine for integer/double/register values,
    this may create nasty, hard to debug issues with Strings. In fact,
    when called with a String at the top of the stack, pushdup would
    only push *a reference* to the same String element (shallow copy),
    later allowing to modify several stack elements at once, which may
    potentially lead to NULL pointer dereferences or any other
    unspecified impact.
    
    In this patch we implement deep copy in pushdup:
    * If the type of the stack element is 's' (for String), we
      allocate a new buffer and copy the String into it.
    * Otherwise we simply proceed as before, that is we do t->val = Stack->val
      which is perfectly fine since we are not dealing with pointers.
    
    This patch is the last part of the patch for #121 (fixes #121), which
    should now be completely fixed.

commit 30170828f1e8e4dff95af6e319b4ad59e64796d9
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri Mar 16 15:56:55 2018 +0100

    Fix heap-buffer-overflow in getString
    
    getString is allocating a 4-bytes buffer to store an 'R' and an
    8-bit number.
    
    t=malloc(4); /* Rdd */
    sprintf(t,"R%d", act->p.RegisterNumber );
    return t;
    
    Since up to three digits can be required to store the 8-bit
    number, the buffer has to be 5 bytes long.
    
    In this commit we also fix the PUSH_DOUBLE case by dynamically
    computing the required buffer size.
    
    This commit fixes #116 (CVE-2018-7867).

commit 8dd118eac8a3c93c2f42089e7af4d7bb8cefd0b3
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Tue Mar 13 22:13:07 2018 +0100

    Fix null pointer dereference in getName/getString
    
    Whenever getString or getName are called with an act such that act->p.String
    is a NULL pointer, a NULL pointer dereference might happen
    (strlen(act->p.string) is called).
    
    In this commit we add checks at the beginning of the PUSH_STRING block so
    that a warning is displayed and an empty string is returned in this case.
    
    This patch fixes #121.

commit 3a000c7b6fe978dd9925266bb6847709e06dbaa3
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Mon Mar 12 09:51:20 2018 +0100

    Fix heap-buffer-overflows when accessing pool
    
    Constants are usually retrieved from the constant pool without verifying
    that the pool actually contains them, which may lead to various heap
    buffer overflow issues.
    
    In this patch we add a counter keeping track of how many elements the pool
    contains, and checks making sure that whenever the pool is accessed, the
    constant in present in the pool (constant position < pool counter).
    
    Also, do not return "" when a pointer is excepted (it should be legal to free
    this return value).
    
    This patch fixes #112 (CVE-2018-7875), fixes #120 (CVE-2018-7871),
    fixes #117 (CVE-2018-7870), fixes #114 (CVE-2018-7872), fixes #122,
    fixes #113 (CVE-2018-7868), fixes #123.

commit 9c53bf8e165c3a74e20f4c93b4ab6c05fe67f187
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Mon Feb 19 18:06:31 2018 +0100

    Use OpCode instead of directly accessing actions
    
    Instead of directly accessing the actions array without checks
    for the value of n (which may lead to heap buffer overflow etc,
    see #83 or #105), use the dedicated OpCode function.

commit f42fdb48986f29278907ab11f615b1c5d2f87530
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Mon Feb 19 17:40:23 2018 +0100

    Fix heap-use-after-free in decompileIF
    
    The decompileIF function in util/decompile.c accesses actions
    array without checking the validity of n, the user entered index.
    This leads to heap-use-after-free issues when n is zero.
    
    This commit addresses this issue by using the OpCode function
    which does check input arguments.
    
    This commit fixes #105 (CVE-2018-6359).

commit 726c2768805c8c95e8ad8e5f09eddc5b16570365
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Mon Dec 4 12:51:16 2017 +0100

    Fix buffer overflow in dcputs (buffer missing \0)
    
    The dcputs function appends passed string at the end of the global
    string buffer (dcstr), adapting the buffer's size if necessary.
    
    Unfortunately, the strsize variable which holds the global buffer's
    size is initialized to 0 in dcinit(), which means that no place for
    the \0 character is reserved. Hence, whenever dcputs tries to strcat
    a string to the global buffer, a byte may be missing leading to a
    heap buffer overflow.
    
    This commit addresses this issue (CVE-2017-11732, closes #80).

commit 8b29e8e7b321bbe102b3d543a7a5f20227371612
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri Oct 27 16:42:55 2017 +0200

    Un-define DEBUGSTACK (util/decompile.c)
    
    pop(), peek() and co. are designed to crash whenever the stack becomes
    NULL but this behavior is currently short-circuited by the DEBUGSTACK
    option, a debug option which allows further processing when Stack == NULL.
    
    With DEBUGSTACK defined, whenever the stack becomes NULL it is replaced
    by a dummy element like "// *** pop(): INTERNAL STACK ERROR FOUND ***".
    
    While this is an acceptable feature for debugging purposes, this is not
    something we want for production because it may lead other functions to
    crash (infinite loops, buffer over reads...) in an especially undebuggabble
    way.

commit eda5a20206862a11805303cdd125566c9f9f9103
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Mon Oct 23 11:23:10 2017 +0200

    Fix null-pointer dereference issue in stackswap.
    
    Avoid processing stackswap when stack only contains one element. In this
    case, print a warning if debug mode is enabled, and return cleanly.
    
    This commit fixes CVE-2017-11733 (fixes #78).

commit 1f5976337d2cf02d5f709cb1d0dac479976e5f94
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri Oct 6 13:35:33 2017 +0200

    Fix heap buffer overflow in decompileCALLFUNCTION
    
    Make sure that n > 0 before checking for the previous action in the
    actions array, otherwise an overflow may occur.
    
    This commit fixes CVE-2017-11734 (fixes #83).

commit 2027b24f403a859016a70bbdc79a8da1d6f128eb
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Fri Oct 6 08:59:32 2017 +0200

    Fix various overflows in OpCode and readBytes
    
    * OpCode: Add a check to avoid reading the stack when n < 1
    
        In this case, print a debug warning and return error code -998
    
    * readBytes: When size < 0, set it to zero (don't read anything)
    
    This commit fixes CVE-2017-11728 (Fixes #82), CVE-2017-11729 (Fixes #79),
    CVE-2017-11730 (Fixes #81) and CVE-2017-11731 (Fixes #84).

commit 7fed314748be817c7ded84854acb649786625cb6
Author: Hugo Lefeuvre <hle@debian.org>
Date:   Sun Oct 1 17:09:45 2017 +0200

    Fix various overflows in util/ (CVE-2017-11704)
    
    * Add a check in decompileIF to avoid overflows.
    
        Avoid processing block when sact->numActions is 0, as
        sact->numActions - 1 may be used as index when accessing
        sact->Actions array.
    
    * Fix overflow in readUInt32.
    
        o Fix declaration of readUInt32 and readSInt32 in util/read.h:
          return types should be unsigned long and long.
        o readUInt32: Avoid calling all readUInt8(f) in one line, order of
          evaluation is not guaranteed in the C standard.
        o readUInt32: Cast result of readUInt8(f) before << 24 to avoid
          overflow.
    
    * Fix overflow in readMovie.
    
        length has int type but according to the specification it should be able
        to store unsigned 32bit numbers. Instead of changing the type of
        length, which would be a major refactoring, we verify that the value
        returned by readUInt32 is smaller than INT_MAX and update length if
        it's the case. Otherwise we print a warning and ignore the block.
    
    This commit fixes CVE-2017-11704.

```
## CVE-2018-7868
- https://github.com/libming/libming/issues/113
- target : decompile.c:398 
- bug type : heap-BOF
- poc : https://github.com/fantasy7082/image_test/blob/master/005-heap-over-swf
- patch commit : 3a000c7b
```diff
--- SRC/util/decompile.c	2024-08-22 12:16:19.965767739 +0000
+++ 20187868/util/decompile.c	2024-08-22 12:19:24.893527981 +0000
@@ -46,6 +46,7 @@


 static char **pool;
+static unsigned short poolcounter;
 struct SWF_ACTIONPUSHPARAM *regs[256];

 static char *getName(struct SWF_ACTIONPUSHPARAM *act);
@@ -395,6 +396,11 @@
   		return t;
 #endif
 	case PUSH_CONSTANT: /* CONSTANT8 */
+		if (act->p.Constant8 > poolcounter)
+		{
+		    SWF_warn("CVE-20187868\n");
+		    exit(1);
+		}
 		t=malloc(strlenext(pool[act->p.Constant8])+1);
 		strcpyext(t,pool[act->p.Constant8]);
 		if(strlen(t)) /* Not a zero length string */
@@ -728,6 +734,7 @@
 {
 	OUT_BEGIN(SWF_ACTIONCONSTANTPOOL);
 	pool=sact->ConstantPool;
+	poolcounter = sact->Count;
 }

 static void
@@ -3411,7 +3418,7 @@
 		return NULL;

 	pool = NULL;
-
+	poolcounter = 0;
 	dcinit();

 	for(j=0;j<256;j++) regs[j]=0;
```


## CVE-2018-11095
- https://github.com/libming/libming/issues/141
- target : decompile.c:1843
- bug type : 
- poc : https://drive.google.com/drive/folders/1E7fkmjdvePRnsDoI1wpuZka0moHG7egl
- patch commit : ?















## CVE-2018-11225
- https://github.com/libming/libming/issues/143
- target : decompile.c:2274
- bug type : null dereference
- poc : https://drive.google.com/drive/folders/1221B4Z577S9YMY_E_C3N9myR2aMGxwKe
- patch commit : 6c24ac4 (branch에 없는 commit)






















## CVE-2018-20427
- https://github.com/libming/libming/issues/164
- target : decompile.c:432
- bug type : null dereference (recursive call)
- poc : https://github.com/libming/libming/files/2404664/segmentaion_fault_decompile_477.zip
``` diff
--- SRC/util/decompile.c	2024-08-22 11:47:10.765046270 +0000
+++ 201820427/util/decompile.c	2024-08-22 11:46:29.653592507 +0000
@@ -429,7 +429,13 @@
 	case PUSH_NULL: /* NULL */
 		return 0;
 	case PUSH_REGISTER: /* REGISTER */
-		return getInt(regs[act->p.RegisterNumber]);
+		if( regs[act->p.RegisterNumber] )
+			return getInt(regs[act->p.RegisterNumber]);
+	    else
+		{
+				SWF_warn("CVE-201820427\n");
+				exit(1);
+		}
 	case PUSH_DOUBLE: /* DOUBLE */
 		return (int)act->p.Double;
 	case PUSH_INT: /* INTEGER */
```


- CVE-2018-9132에 대한 poc도 막힘 (왜 다른 CVE인것일까?)
``` log
(gdb) r poc/libming-4.8/20189132
Program received signal SIGSEGV, Segmentation fault.
0x0000000000410f10 in getInt (act=0x0) at decompile.c:425
425             switch( act->Type )
(gdb) bt
#0  0x0000000000410f10 in getInt (act=0x0) at decompile.c:425
#1  0x0000000000410f6f in getInt (act=0xa6ac00) at decompile.c:432
#2  0x000000000040a16a in decompileGETPROPERTY (n=2, actions=0xa6b0f0, maxn=9) at decompile.c:1390
#3  0x0000000000409232 in decompileAction (n=2, actions=0xa6b0f0, maxn=9) at decompile.c:3167
#4  0x00000000004100e6 in decompileActions (n=9, actions=0xa6b0f0, indent=0) at decompile.c:3401
#5  0x000000000040ffd9 in decompile5Action (n=9, actions=0xa6b0f0, indent=0) at decompile.c:3423
#6  0x000000000040646c in outputSWF_DOACTION (pblock=0xa6a490) at outputscript.c:1548
#7  0x0000000000405be6 in outputBlock (type=12, blockp=0xa6a490, stream=0xa692a0) at outputscript.c:2079
#8  0x0000000000408468 in readMovie (f=0xa692a0) at main.c:277
#9  0x0000000000407fbf in main (argc=2, argv=0x7fffcadedc38) at main.c:350
```

- CVE-2018-20427
``` log
(gdb) r poc/libming-4.8/201820427
Program received signal SIGSEGV, Segmentation fault.
0x0000000000410f10 in getInt (act=0x0) at decompile.c:425
425             switch( act->Type )
(gdb) bt
#0  0x0000000000410f10 in getInt (act=0x0) at decompile.c:425
#1  0x0000000000410f6f in getInt (act=0x23a8ce0) at decompile.c:432
#2  0x000000000040a11f in decompileGETPROPERTY (n=11, actions=0x23a99a0, maxn=14) at decompile.c:1388
#3  0x0000000000409232 in decompileAction (n=11, actions=0x23a99a0, maxn=14) at decompile.c:3167
#4  0x00000000004100e6 in decompileActions (n=14, actions=0x23a99a0, indent=0) at decompile.c:3401
#5  0x000000000040ffd9 in decompile5Action (n=14, actions=0x23a99a0, indent=0) at decompile.c:3423
#6  0x000000000040646c in outputSWF_DOACTION (pblock=0x23a65a0) at outputscript.c:1548
#7  0x0000000000405be6 in outputBlock (type=12, blockp=0x23a65a0, stream=0x23a52a0) at outputscript.c:2079
#8  0x0000000000408468 in readMovie (f=0x23a52a0) at main.c:277
#9  0x0000000000407fbf in main (argc=2, argv=0x7ffcc3ed17f8) at main.c:350
```